<!DOCTYPE html>
<html>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="一. 关于fork调用　　fork()调用创建一个新的进程，该进程几乎是当前进程的一个完全拷贝。由fork()创建的新进程被称为子进程。fork函数被调用一次但返回两次。两次返回的唯一区别是子进程中返回0值，而父进程中返回子进程ID。子进程是父进程的副本，它将获得父进程数据空间、堆、栈等资源的副本。注意，子进程持有的是上述存储空间的“副本”，这意味着父子进程间不共享这些存储空间。Linux将复制父">
<meta name="keywords" content="linux">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解Linux之进程初探">
<meta property="og:url" content="http://www.amendgit.com/2017/linux-understand-process/index.html">
<meta property="og:site_name" content="amendgit&#39;s blog">
<meta property="og:description" content="一. 关于fork调用　　fork()调用创建一个新的进程，该进程几乎是当前进程的一个完全拷贝。由fork()创建的新进程被称为子进程。fork函数被调用一次但返回两次。两次返回的唯一区别是子进程中返回0值，而父进程中返回子进程ID。子进程是父进程的副本，它将获得父进程数据空间、堆、栈等资源的副本。注意，子进程持有的是上述存储空间的“副本”，这意味着父子进程间不共享这些存储空间。Linux将复制父">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://www.amendgit.com/2017/linux-understand-process/system_call.png">
<meta property="og:updated_time" content="2017-07-07T02:42:54.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入理解Linux之进程初探">
<meta name="twitter:description" content="一. 关于fork调用　　fork()调用创建一个新的进程，该进程几乎是当前进程的一个完全拷贝。由fork()创建的新进程被称为子进程。fork函数被调用一次但返回两次。两次返回的唯一区别是子进程中返回0值，而父进程中返回子进程ID。子进程是父进程的副本，它将获得父进程数据空间、堆、栈等资源的副本。注意，子进程持有的是上述存储空间的“副本”，这意味着父子进程间不共享这些存储空间。Linux将复制父">
<meta name="twitter:image" content="http://www.amendgit.com/2017/linux-understand-process/system_call.png">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>深入理解Linux之进程初探</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- rss -->
    
    
</head>

<body>
    
      <div id="header-post">
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="http://github.com/amendgit">Projects</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        <li><a class="icon" href="#"><i class="fa fa-bars fa-lg" aria-hidden="true" onmouseover='$("#i-toc").toggle();' onmouseout='$("#i-toc").toggle();' onclick='$("#toc").toggle();return false;'></i></a></li>
        
        <li><a class="icon" href="/2017/cs224n-assignment-1/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li>
        
        
        <li><a class="icon" href="/2017/linux-how-computer-works/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li>
        <li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li>
      </ul>
      <span id="i-toc" class="info" style="display:none;">Table of content</span>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://www.amendgit.com/2017/linux-understand-process/"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://www.amendgit.com/2017/linux-understand-process/&text=深入理解Linux之进程初探"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://www.amendgit.com/2017/linux-understand-process/&title=深入理解Linux之进程初探"><i class="fa fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://www.amendgit.com/2017/linux-understand-process/&is_video=false&description=深入理解Linux之进程初探"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=深入理解Linux之进程初探&body=Check out this article: http://www.amendgit.com/2017/linux-understand-process/"><i class="fa fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://www.amendgit.com/2017/linux-understand-process/&title=深入理解Linux之进程初探"><i class="fa fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://www.amendgit.com/2017/linux-understand-process/&title=深入理解Linux之进程初探"><i class="fa fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://www.amendgit.com/2017/linux-understand-process/&title=深入理解Linux之进程初探"><i class="fa fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://www.amendgit.com/2017/linux-understand-process/&title=深入理解Linux之进程初探"><i class="fa fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://www.amendgit.com/2017/linux-understand-process/&name=深入理解Linux之进程初探&description="><i class="fa fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一-关于fork调用"><span class="toc-number">1.</span> <span class="toc-text">一. 关于fork调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二-关于execl调用"><span class="toc-number">2.</span> <span class="toc-text">二. 关于execl调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三-使用汇编进行系统调用"><span class="toc-number">3.</span> <span class="toc-text">三. 使用汇编进行系统调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四-系统调用过程详解"><span class="toc-number">4.</span> <span class="toc-text">四.系统调用过程详解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四-do-fork源码分析"><span class="toc-number">5.</span> <span class="toc-text">四.do_fork源码分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五-do-execve的分析"><span class="toc-number">6.</span> <span class="toc-text">五.do_execve的分析</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index width mx-auto px2 my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        深入理解Linux之进程初探
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">amendgit's blog</span>
      </span>
      
    <div class="postdate">
        <time datetime="2017-07-01T02:57:53.000Z" itemprop="datePublished">2017-07-01</time>
    </div>


      
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/linux/">linux</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="一-关于fork调用"><a href="#一-关于fork调用" class="headerlink" title="一. 关于fork调用"></a>一. 关于fork调用</h2><p>　　fork()调用创建一个新的进程，该进程几乎是当前进程的一个完全拷贝。由fork()创建的新进程被称为子进程。fork函数被调用一次但返回两次。两次返回的唯一区别是子进程中返回0值，而父进程中返回子进程ID。子进程是父进程的副本，它将获得父进程数据空间、堆、栈等资源的副本。注意，子进程持有的是上述存储空间的“副本”，这意味着父子进程间不共享这些存储空间。Linux将复制父进程的地址空间内容给子进程，因此，子进程拥有独立的地址空间。<br>　　我们来看一个DEMO:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fork_example.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> stack_data[] = <span class="string">"stack_data"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *heap_data = <span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));    </span><br><span class="line">    <span class="built_in">strcpy</span>(heap_data, <span class="string">"heap_data"</span>);</span><br><span class="line">    </span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"CHILD PROCESS: %s, %s\n"</span>, stack_data, heap_data);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"PARENT PROCESS: %s, %s\n"</span>, stack_data, heap_data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"FORK FAILED."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行的输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CHILD PROCESS: stack_data, heap_data</span><br><span class="line">PARENT PROCESS: stack_data, heap_data</span><br></pre></td></tr></table></figure>
<p>可以看出，父进程和子进程的栈和堆的数据是相同的。这些数据在创建子进程时是通过拷贝产生的。</p>
<h2 id="二-关于execl调用"><a href="#二-关于execl调用" class="headerlink" title="二. 关于execl调用"></a>二. 关于execl调用</h2><p>系统调用exec是以新的进程去代替原来的进程，但进程的PID保持不变。因此，可以这样认为，exec系统调用并没有创建新的进程，只是替换了原来进程上下文的内容。原进程的代码段，数据段，堆栈段被新的进程所代替。</p>
<p>我们来看一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// execl_example.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    execl(<span class="string">"./hello_world"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* We can only reach this code when there is an error in execl */</span>    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The execl must be failed!\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们执行一个不存在的hello_world程序，看看输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The execl must be failed!</span><br></pre></td></tr></table></figure>
<p>现在我们创建一个hello_world程序，该程序简单的打印一个Hello World.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello_world.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World!\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们继续运行execl_example程序，这时输出为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World!</span><br></pre></td></tr></table></figure>
<h2 id="三-使用汇编进行系统调用"><a href="#三-使用汇编进行系统调用" class="headerlink" title="三. 使用汇编进行系统调用"></a>三. 使用汇编进行系统调用</h2><p>我们知道在Linux中，每个系统调用都对应一个系统调用号。这个系统调用号是在unistd.h中定义的。在我的机器上文件的位置是在：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/src/linux-headers-2.6.28-11-generic/arch/x86/include/asm/unistd_32.h</span><br></pre></td></tr></table></figure>
<p>如果找不到，可以尝试使用以下命令查找：</p>
<p>locate unistd.h | xargs grep -ri “__NR_fork”</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">... ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_restart_syscall      0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_exit          1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fork          2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_read          3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_write          4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_open          5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_close          6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_waitpid          7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_creat          8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_link          9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_unlink         10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_execve         11</span></span><br><span class="line">... ...</span><br></pre></td></tr></table></figure>
<p><strong>使用汇编调用fork:</strong></p>
<p>可以看到fork的系统调用号是2，我们现在使用汇编代码重新编写fork_example.c</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> stack_data[] = <span class="string">"stack_data"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *heap_data = <span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));    </span><br><span class="line">    <span class="built_in">strcpy</span>(heap_data, <span class="string">"heap_data"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pid = fork();</span></span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"mov $0x2, %%eax\n\t"</span> <span class="comment">// 将fork的系统调用号2存到eax寄存器  </span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"int $0x80\n\t"</span>       <span class="comment">// 产生int 0x80中断</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"mov %%eax,%0\n\t"</span>    <span class="comment">// 将结果存入pid中</span></span></span></span><br><span class="line"><span class="function"><span class="params">        : <span class="string">"=m"</span> (pid)</span> </span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"CHILD PROCESS: %s, %s\n"</span>, stack_data, heap_data);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"PARENT PROCESS: %s, %s\n"</span>, stack_data, heap_data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"FORK FAILED.\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行输出结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CHILD PROCESS: stack_data, heap_data</span><br><span class="line">PARENT PROCESS: stack_data, heap_data</span><br></pre></td></tr></table></figure>
<p>可以尝试将调用号替换一下，改成$0x3，得到的结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FORK FAILED.</span><br></pre></td></tr></table></figure>
<p><strong>使用汇编调用execl:</strong></p>
<p>我们再尝试一下使用汇编调用execl。通过上面的观察我们可以看到execl的系统调用号是11.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// execl("./hello_world", NULL, NULL);</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *program = <span class="string">"./hello_world"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"mov %0,%%ebx\n\t"</span>   <span class="comment">// 使用program做为参数1</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"mov $0,%%ecx\n\t"</span>   <span class="comment">// 参数2为NULL</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"mov $0,%%edx\n\t"</span>   <span class="comment">// 参数3为NULL</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"mov $0xb,%%eax\n\t"</span> <span class="comment">// 将execl的系统调用好11存入eax中</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"int $0x80\n\t"</span>      <span class="comment">// 产生0x80中断</span></span></span></span><br><span class="line"><span class="function"><span class="params">        : <span class="string">"=m"</span> (program)</span></span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* We can only reach this code when there is an error in execl */</span>    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The execl must be failed!\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World!</span><br></pre></td></tr></table></figure>
<p>如果将系统调用号改为0x3，输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The execl must be failed!</span><br></pre></td></tr></table></figure>
<h2 id="四-系统调用过程详解"><a href="#四-系统调用过程详解" class="headerlink" title="四.系统调用过程详解"></a>四.系统调用过程详解</h2><p>通过第三步的过程，我们了解到，系统调用在内核中的执行是依靠中断实现的。如果我们想进一步定位fork和execl的代码，我们需要先了解系统调用的详细过程。即回答以下两个问题：</p>
<p>1.中断是怎么工作的？<br>2.int 0x80中断是怎么工作的？</p>
<p>中断是怎么工作的</p>
<p>在Linux操作系统中，中断是通过中断描述符表工作的。中断描述符表（Interrupt Descriptor Table, IDT）是一个系统表，它与每一个中断或者异常向量相联系，每一个向量在表中有相应的中断或者异常处理程序的入口地址。内核在允许中断发生前，必须适当的初始化IDT。对于每个中断，都会有对应的中断处理程序。当产生一个中断时，Linux根据中断向量表中对应的项找到存储中断处理程序的地址，然后调用相应的中断处理程序。中段描述符表在内存中的地址存储在idtr寄存器中。内核在启动中断前，必须初始化IDT，然后将IDT的地址壮载到idtr中。</p>
<p>内核初始化的时候调用trap_init()函数和init_IRQ()函数初始化中断向量表。</p>
<p>int 0x80中断是怎么工作的</p>
<p>通过上面的分析，我们知道每个中断都有对应的处理程序。在系统调用的过程中，会有一个系统调用分派表，每个表项存储了一个系统调用。系统调用中断处理程序，根据系统调用号找到对应的系统调用执行。对于系统调用，参数的传递是通过寄存器ebx ecx edx进行传递的。eax中存储的是系统调用号。系统调用最大为__NR_syscalls个。</p>
<p><img src="/2017/linux-understand-process/system_call.png" alt=""></p>
<p>在arch/x86/include/asm/irq_vectors.h中定义了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> SYSCALL_VECTOR            0x80</span></span><br></pre></td></tr></table></figure>
<p>现在我们查找trap_init函数，在arch/x86/kernel/traps.c中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_system_trap_gate(SYSCALL_VECTOR, &amp;system_call);</span><br></pre></td></tr></table></figure>
<p>现在，查找system_call函数，在arch/x86/kernel/entry_32.s中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(system_call)</span><br><span class="line">    RING0_INT_FRAME            # can&apos;t unwind into user space anyway</span><br><span class="line">    ASM_CLAC</span><br><span class="line">    pushl_cfi %eax            # save orig_eax</span><br><span class="line">    SAVE_ALL</span><br><span class="line">    GET_THREAD_INFO(%ebp)</span><br><span class="line">                    # system call tracing in operation / emulation</span><br><span class="line">    testl $_TIF_WORK_SYSCALL_ENTRY,TI_flags(%ebp)</span><br><span class="line">    jnz syscall_trace_entry</span><br><span class="line">    cmpl $(NR_syscalls), %eax</span><br><span class="line">    jae syscall_badsys</span><br><span class="line">syscall_call:</span><br><span class="line">    call *sys_call_table(,%eax,4)</span><br><span class="line">    movl %eax,PT_EAX(%esp)        # store the return value</span><br><span class="line">syscall_exit:</span><br><span class="line">    LOCKDEP_SYS_EXIT</span><br><span class="line">    DISABLE_INTERRUPTS(CLBR_ANY)    # make sure we don&apos;t miss an interrupt</span><br><span class="line">                    # setting need_resched or sigpending</span><br><span class="line">                    # between sampling and the iret</span><br><span class="line">    TRACE_IRQS_OFF</span><br><span class="line">    movl TI_flags(%ebp), %ecx</span><br><span class="line">    testl $_TIF_ALLWORK_MASK, %ecx    # current-&gt;work</span><br><span class="line">    jne syscall_exit_work</span><br></pre></td></tr></table></figure>
<p>在include/uapi/asm_generic/unistd.h中找到：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__SYSCALL(__NR_fork, sys_fork)</span><br></pre></td></tr></table></figure>
<p>fork的系统调用号是2，对应的系统调用分派表中为sys_fork函数。在kernel/fork.c中找到如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __ARCH_WANT_SYS_FORK</span></span><br><span class="line">SYSCALL_DEFINE0(fork)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MMU</span></span><br><span class="line">    <span class="keyword">return</span> do_fork(SIGCHLD, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">/* can not support in nommu mode */</span></span><br><span class="line">    <span class="keyword">return</span>(-EINVAL);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="四-do-fork源码分析"><a href="#四-do-fork源码分析" class="headerlink" title="四.do_fork源码分析"></a>四.do_fork源码分析</h2><p>现在查找do_fork函数，也在kernel/fork.c中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  Ok, 这就是fork例程的主要部分。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 函数执行进程的复制，如果成功则启动新进程。并且等待新进程完成VM的使用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">do_fork</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_start,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_size,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">int</span> __user *parent_tidptr,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">int</span> __user *child_tidptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">int</span> trace = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> nr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 在分配之前做一些参数和权限检查。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; (CLONE_NEWUSER | CLONE_NEWPID)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (clone_flags &amp; (CLONE_THREAD|CLONE_PARENT))</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 确定是否需要报告给ptracer，或者哪些需要汇报给ptracer。如果是调用者内核线程</span></span><br><span class="line"><span class="comment">     * 或者标志了CLONE_UNTRACED，则不报告任何跟踪信息。否则，报告相应fork的跟踪信息。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!(clone_flags &amp; CLONE_UNTRACED)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (clone_flags &amp; CLONE_VFORK)</span><br><span class="line">            trace = PTRACE_EVENT_VFORK;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((clone_flags &amp; CSIGNAL) != SIGCHLD)</span><br><span class="line">            trace = PTRACE_EVENT_CLONE;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            trace = PTRACE_EVENT_FORK;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (likely(!ptrace_event_enabled(current, trace)))</span><br><span class="line">            trace = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">　　</span><br><span class="line">    <span class="comment">/* copy_process函数创建进程描述符和子进程需要的其他数据结构。*/</span></span><br><span class="line">    p = copy_process(clone_flags, stack_start, stack_size,</span><br><span class="line">             child_tidptr, <span class="literal">NULL</span>, trace);</span><br><span class="line">             </span><br><span class="line">    <span class="comment">/* 现在唤醒新线程。*/</span></span><br><span class="line">    <span class="keyword">if</span> (!IS_ERR(p)) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">vfork</span>;</span></span><br><span class="line"></span><br><span class="line">        trace_sched_process_fork(current, p);</span><br><span class="line"></span><br><span class="line">        nr = task_pid_vnr(p);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clone_flags &amp; CLONE_PARENT_SETTID)</span><br><span class="line">            put_user(nr, parent_tidptr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clone_flags &amp; CLONE_VFORK) &#123;</span><br><span class="line">            p-&gt;vfork_done = &amp;vfork;</span><br><span class="line">            init_completion(&amp;vfork);</span><br><span class="line">            get_task_struct(p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        wake_up_new_task(p);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* fork已经完成，子进程也已经启动。现在通知ptracer。 */</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(trace))</span><br><span class="line">            ptrace_event(trace, nr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clone_flags &amp; CLONE_VFORK) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!wait_for_vfork_done(p, &amp;vfork))</span><br><span class="line">                ptrace_event(PTRACE_EVENT_VFORK_DONE, nr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nr = PTR_ERR(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到do_fork调用了copy_process完成了绝大部分的工作。copy_process位于同一个文件当中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 以复制的方式创建一个新的进程。但不启动运行新创建的进程。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 主要复制寄存器和其它进程环境中的相应的合适部分。真正的</span></span><br><span class="line"><span class="comment"> * 启动工作则交由调用者完成。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct task_struct *<span class="title">copy_process</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_start,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">int</span> __user *child_tidptr,</span></span></span><br><span class="line"><span class="function"><span class="params">                    struct pid *pid,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">int</span> trace)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span> <span class="comment">// 保存新的进程描述符。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 删除了对标志位的一致性和合法性的检查 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// security_task_create和security_task_alloc()执行所有附加的安全检查。</span></span><br><span class="line">    retval = security_task_create(clone_flags);</span><br><span class="line">    <span class="comment">// dup_task_struct为子进程获取进程描述符。稍后分析。</span></span><br><span class="line">    p = dup_task_struct(current);</span><br><span class="line">    <span class="comment">// task结构中ftrace_ret_stack结构变量的初始化，即函数返回用的栈。</span></span><br><span class="line">    ftrace_graph_init_task(p);</span><br><span class="line">    get_seccomp_filter(p);</span><br><span class="line">    <span class="comment">// task中互斥变量的初始化。</span></span><br><span class="line">    rt_mutex_init_task(p);</span><br><span class="line">    <span class="comment">// 第1个if对进程占用的资源数做出限制，task_rlimit(p, RLIMIT_NPROC)</span></span><br><span class="line">    <span class="comment">// 限制了改进程用户可以拥有的进程总数。 </span></span><br><span class="line">    <span class="keyword">if</span> (atomic_read(&amp;p-&gt;real_cred-&gt;user-&gt;processes) &gt;= task_rlimit(p, RLIMIT_NPROC)) &#123;</span><br><span class="line">        <span class="comment">// 第2个if使用了capable（）函数来对权限做出检查，检查是否有权对指定</span></span><br><span class="line">        <span class="comment">// 的资源进行操作，该函数返回0则代表无权操作。</span></span><br><span class="line">        <span class="keyword">if</span> (!capable(CAP_SYS_ADMIN) &amp;&amp; !capable(CAP_SYS_RESOURCE) &amp;&amp; p-&gt;real_cred-&gt;user != INIT_USER)</span><br><span class="line">            <span class="keyword">goto</span> bad_fork_free;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    current-&gt;flags &amp;= ~PF_NPROC_EXCEEDED; <span class="comment">// 将当前进程标志位中的PF_NPROC_EXCEEDED置0。</span></span><br><span class="line">    copy_creds(p, clone_flags); <span class="comment">// copy_creds()复制证书，应该是复制权限及身份信息。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查创建的线程是否超过了系统进程总量。</span></span><br><span class="line">    <span class="keyword">if</span> (nr_threads &gt;= max_threads)</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_count;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 增加执行实体的模块引用计数。</span></span><br><span class="line">    <span class="keyword">if</span> (!try_module_get(task_thread_info(p)-&gt;exec_domain-&gt;<span class="keyword">module</span>))</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_count;</span><br><span class="line"></span><br><span class="line">    p-&gt;did_exec = <span class="number">0</span>;</span><br><span class="line">    delayacct_tsk_init(p);    <span class="comment">/* Must remain after dup_task_struct() */</span></span><br><span class="line">    copy_flags(clone_flags, p); <span class="comment">// 更新task_struct结构中flags成员</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;p-&gt;children); <span class="comment">// 初始化task_struct结构中的子进程链表</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;p-&gt;sibling); <span class="comment">// 初始化task_struct结构中的兄弟进程链表</span></span><br><span class="line">    rcu_copy_process(p); <span class="comment">// rcu相关变量的初始化</span></span><br><span class="line">    p-&gt;vfork_done = <span class="literal">NULL</span>; </span><br><span class="line">    spin_lock_init(&amp;p-&gt;alloc_lock); </span><br><span class="line"></span><br><span class="line">    init_sigpending(&amp;p-&gt;pending);</span><br><span class="line"></span><br><span class="line">    p-&gt;utime = p-&gt;stime = p-&gt;gtime = <span class="number">0</span>;</span><br><span class="line">    p-&gt;utimescaled = p-&gt;stimescaled = <span class="number">0</span>;</span><br><span class="line">    p-&gt;prev_cputime.utime = p-&gt;prev_cputime.stime = <span class="number">0</span>;</span><br><span class="line">    seqlock_init(&amp;p-&gt;vtime_seqlock);</span><br><span class="line">    p-&gt;vtime_snap = <span class="number">0</span>;</span><br><span class="line">    p-&gt;vtime_snap_whence = VTIME_SLEEPING;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;p-&gt;rss_stat, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;rss_stat));</span><br><span class="line"></span><br><span class="line">    p-&gt;default_timer_slack_ns = current-&gt;timer_slack_ns;</span><br><span class="line"></span><br><span class="line">    task_io_accounting_init(&amp;p-&gt;ioac); <span class="comment">// 进程描述符中的io数据记录的初始化</span></span><br><span class="line">    acct_clear_integrals(p);</span><br><span class="line"></span><br><span class="line">    posix_cpu_timers_init(p); <span class="comment">// timer初始化</span></span><br><span class="line"></span><br><span class="line">    do_posix_clock_monotonic_gettime(&amp;p-&gt;start_time);</span><br><span class="line">    p-&gt;real_start_time = p-&gt;start_time;</span><br><span class="line">    monotonic_to_bootbased(&amp;p-&gt;real_start_time);</span><br><span class="line">    p-&gt;io_context = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;audit_context = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_THREAD)</span><br><span class="line">        threadgroup_change_begin(current);</span><br><span class="line">    cgroup_fork(p);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    p-&gt;mempolicy = mpol_dup(p-&gt;mempolicy);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(p-&gt;mempolicy)) &#123;</span><br><span class="line">        retval = PTR_ERR(p-&gt;mempolicy);</span><br><span class="line">        p-&gt;mempolicy = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_cgroup;</span><br><span class="line">    &#125;</span><br><span class="line">    mpol_fix_fork_child_flag(p);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* 设置CPU */</span></span><br><span class="line">    p-&gt;cpuset_mem_spread_rotor = NUMA_NO_NODE;</span><br><span class="line">    p-&gt;cpuset_slab_spread_rotor = NUMA_NO_NODE;</span><br><span class="line">    seqcount_init(&amp;p-&gt;mems_allowed_seq);</span><br><span class="line">    <span class="comment">/* 设置跟踪中断标志 */</span> </span><br><span class="line">    p-&gt;irq_events = <span class="number">0</span>;</span><br><span class="line">    p-&gt;hardirqs_enabled = <span class="number">0</span>;</span><br><span class="line">    p-&gt;hardirq_enable_ip = <span class="number">0</span>;</span><br><span class="line">    p-&gt;hardirq_enable_event = <span class="number">0</span>;</span><br><span class="line">    p-&gt;hardirq_disable_ip = _THIS_IP_;</span><br><span class="line">    p-&gt;hardirq_disable_event = <span class="number">0</span>;</span><br><span class="line">    p-&gt;softirqs_enabled = <span class="number">1</span>;</span><br><span class="line">    p-&gt;softirq_enable_ip = _THIS_IP_;</span><br><span class="line">    p-&gt;softirq_enable_event = <span class="number">0</span>;</span><br><span class="line">    p-&gt;softirq_disable_ip = <span class="number">0</span>;</span><br><span class="line">    p-&gt;softirq_disable_event = <span class="number">0</span>;</span><br><span class="line">    p-&gt;hardirq_context = <span class="number">0</span>;</span><br><span class="line">    p-&gt;softirq_context = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 设置锁深度 */</span></span><br><span class="line">    p-&gt;lockdep_depth = <span class="number">0</span>; <span class="comment">/* no locks held yet */</span></span><br><span class="line">    p-&gt;curr_chain_key = <span class="number">0</span>;</span><br><span class="line">    p-&gt;lockdep_recursion = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_MUTEXES</span></span><br><span class="line">    p-&gt;blocked_on = <span class="literal">NULL</span>; <span class="comment">/* not blocked yet */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line">    p-&gt;memcg_batch.do_batch = <span class="number">0</span>;</span><br><span class="line">    p-&gt;memcg_batch.memcg = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    sched_fork(p); <span class="comment">// 调度相关初始化,将新进程分配到某个CPU上。</span></span><br><span class="line"></span><br><span class="line">    perf_event_init_task(p);</span><br><span class="line">    audit_alloc(p);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/* 以下根据clone_flags的设置复制相应的部分，进行重新分配或者共享父进程的内容 */</span></span><br><span class="line">    copy_semundo(clone_flags, p);</span><br><span class="line">    copy_files(clone_flags, p);</span><br><span class="line">    copy_fs(clone_flags, p);</span><br><span class="line">    copy_sighand(clone_flags, p);</span><br><span class="line">    copy_signal(clone_flags, p);</span><br><span class="line">    copy_mm(clone_flags, p);</span><br><span class="line">    copy_namespaces(clone_flags, p);</span><br><span class="line">    copy_io(clone_flags, p);</span><br><span class="line">    copy_thread(clone_flags, stack_start, stack_size, p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid != &amp;init_struct_pid) &#123;</span><br><span class="line">        retval = -ENOMEM;</span><br><span class="line">        pid = alloc_pid(p-&gt;nsproxy-&gt;pid_ns);</span><br><span class="line">        <span class="keyword">if</span> (!pid)</span><br><span class="line">            <span class="keyword">goto</span> bad_fork_cleanup_io;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p-&gt;pid = pid_nr(pid);</span><br><span class="line">    p-&gt;tgid = p-&gt;pid;</span><br><span class="line">    <span class="comment">// 如果设置了同在一个线程组则继承TGID。 </span></span><br><span class="line">    <span class="comment">// 对于普通进程来说TGID和PID相等， </span></span><br><span class="line">    <span class="comment">// 对于线程来说，同一线程组内的所有线程的TGID都相等， </span></span><br><span class="line">    <span class="comment">// 这使得这些多线程可以通过调用getpid()获得相同的PID。</span></span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_THREAD)</span><br><span class="line">        p-&gt;tgid = current-&gt;tgid;</span><br><span class="line"></span><br><span class="line">    p-&gt;set_child_tid = (clone_flags &amp; CLONE_CHILD_SETTID) ? child_tidptr : <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Clear TID on mm_release()?</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    p-&gt;clear_child_tid = (clone_flags &amp; CLONE_CHILD_CLEARTID) ? child_tidptr : <span class="literal">NULL</span>;</span><br><span class="line">    uprobe_copy_process(p);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * sigaltstack should be cleared when sharing the same VM</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((clone_flags &amp; (CLONE_VM|CLONE_VFORK)) == CLONE_VM)</span><br><span class="line">        p-&gt;sas_ss_sp = p-&gt;sas_ss_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Syscall tracing and stepping should be turned off in the</span></span><br><span class="line"><span class="comment">     * child regardless of CLONE_PTRACE.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    user_disable_single_step(p);</span><br><span class="line">    clear_tsk_thread_flag(p, TIF_SYSCALL_TRACE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TIF_SYSCALL_EMU</span></span><br><span class="line">    clear_tsk_thread_flag(p, TIF_SYSCALL_EMU);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    clear_all_latency_tracing(p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ok, now we should be set up.. */</span></span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_THREAD)</span><br><span class="line">        p-&gt;exit_signal = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (clone_flags &amp; CLONE_PARENT)</span><br><span class="line">        p-&gt;exit_signal = current-&gt;group_leader-&gt;exit_signal;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        p-&gt;exit_signal = (clone_flags &amp; CSIGNAL);</span><br><span class="line"></span><br><span class="line">    p-&gt;pdeath_signal = <span class="number">0</span>;</span><br><span class="line">    p-&gt;exit_state = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    p-&gt;nr_dirtied = <span class="number">0</span>;</span><br><span class="line">    p-&gt;nr_dirtied_pause = <span class="number">128</span> &gt;&gt; (PAGE_SHIFT - <span class="number">10</span>);</span><br><span class="line">    p-&gt;dirty_paused_when = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ok, make it visible to the rest of the system.</span></span><br><span class="line"><span class="comment">     * We dont wake it up yet.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    p-&gt;group_leader = p;</span><br><span class="line">    INIT_LIST_HEAD(&amp;p-&gt;thread_group);</span><br><span class="line">    p-&gt;task_works = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Need tasklist lock for parent etc handling! */</span></span><br><span class="line">    write_lock_irq(&amp;tasklist_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果这两个标志设定了，那么和父进程有相同的父进程</span></span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; (CLONE_PARENT|CLONE_THREAD)) &#123;</span><br><span class="line">        p-&gt;real_parent = current-&gt;real_parent;</span><br><span class="line">        p-&gt;parent_exec_id = current-&gt;parent_exec_id;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="comment">// 否则父进程为实际父进程</span></span><br><span class="line">        p-&gt;real_parent = current;</span><br><span class="line">        p-&gt;parent_exec_id = current-&gt;self_exec_id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    spin_lock(¤t-&gt;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Process group and session signals need to be delivered to just the</span></span><br><span class="line"><span class="comment">     * parent before the fork or both the parent and the child after the</span></span><br><span class="line"><span class="comment">     * fork. Restart if a signal comes in before we add the new process to</span></span><br><span class="line"><span class="comment">     * it's process group.</span></span><br><span class="line"><span class="comment">     * A fatal signal pending means that current will exit, so the new</span></span><br><span class="line"><span class="comment">     * thread can't slip out of an OOM kill (or normal SIGKILL).</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    recalc_sigpending();</span><br><span class="line">    <span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">        spin_unlock(¤t-&gt;sighand-&gt;siglock);</span><br><span class="line">        write_unlock_irq(&amp;tasklist_lock);</span><br><span class="line">        retval = -ERESTARTNOINTR;</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_free_pid;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果和父进程有相同的线程组</span></span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_THREAD) &#123;</span><br><span class="line">        current-&gt;signal-&gt;nr_threads++;</span><br><span class="line">        atomic_inc(¤t-&gt;signal-&gt;live);</span><br><span class="line">        atomic_inc(¤t-&gt;signal-&gt;sigcnt);</span><br><span class="line">        p-&gt;group_leader = current-&gt;group_leader;</span><br><span class="line">        list_add_tail_rcu(&amp;p-&gt;thread_group, &amp;p-&gt;group_leader-&gt;thread_group);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (likely(p-&gt;pid)) &#123;</span><br><span class="line">        ptrace_init_task(p, (clone_flags &amp; CLONE_PTRACE) || trace); <span class="comment">// ptrace的相关初始化</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果进程p是线程组leader</span></span><br><span class="line">        <span class="keyword">if</span> (thread_group_leader(p)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (is_child_reaper(pid)) &#123;</span><br><span class="line">                ns_of_pid(pid)-&gt;child_reaper = p;</span><br><span class="line">                p-&gt;signal-&gt;flags |= SIGNAL_UNKILLABLE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            p-&gt;signal-&gt;leader_pid = pid;</span><br><span class="line">            p-&gt;signal-&gt;tty = tty_kref_get(current-&gt;signal-&gt;tty);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* 加入对应的PID哈希表 */</span></span><br><span class="line">            attach_pid(p, PIDTYPE_PGID, task_pgrp(current));</span><br><span class="line">            attach_pid(p, PIDTYPE_SID, task_session(current));</span><br><span class="line">            </span><br><span class="line">            list_add_tail(&amp;p-&gt;sibling, &amp;p-&gt;real_parent-&gt;children);</span><br><span class="line">            list_add_tail_rcu(&amp;p-&gt;tasks, &amp;init_task.tasks); <span class="comment">// 加入队列</span></span><br><span class="line">            __this_cpu_inc(process_counts); <span class="comment">// 将per cpu变量加一</span></span><br><span class="line">        &#125;</span><br><span class="line">        attach_pid(p, PIDTYPE_PID, pid); <span class="comment">// 维护pid变量</span></span><br><span class="line">        nr_threads++; <span class="comment">// 线程数加1。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    total_forks++; <span class="comment">// 将全局变量total_forks加1.</span></span><br><span class="line">    spin_unlock(¤t-&gt;sighand-&gt;siglock);</span><br><span class="line">    write_unlock_irq(&amp;tasklist_lock);</span><br><span class="line">    proc_fork_connector(p);</span><br><span class="line">    cgroup_post_fork(p);</span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_THREAD)</span><br><span class="line">        threadgroup_change_end(current);</span><br><span class="line">    perf_event_fork(p);</span><br><span class="line"></span><br><span class="line">    trace_task_newtask(p, clone_flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dup_task_struct也在fork.c文件中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct task_struct *<span class="title">dup_task_struct</span><span class="params">(struct task_struct *orig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span>;</span> <span class="comment">// 存放新的task_sturct结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> *<span class="title">ti</span>;</span> <span class="comment">// 存放线程信息</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *stackend; </span><br><span class="line">    <span class="keyword">int</span> node = tsk_fork_get_node(orig); </span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    tsk = alloc_task_struct_node(node); <span class="comment">// 通过alloc_task_struct()函数创建task_struct结构空间</span></span><br><span class="line"></span><br><span class="line">    ti = alloc_thread_info_node(tsk, node); <span class="comment">// 分配thread_info结构空间</span></span><br><span class="line"></span><br><span class="line">    err = arch_dup_task_struct(tsk, orig); <span class="comment">// 关于浮点结构的复制</span></span><br><span class="line">    </span><br><span class="line">    tsk-&gt;<span class="built_in">stack</span> = ti; <span class="comment">// task的对应栈</span></span><br><span class="line"></span><br><span class="line">    setup_thread_stack(tsk, orig);</span><br><span class="line">    clear_user_return_notifier(tsk);</span><br><span class="line">    clear_tsk_need_resched(tsk);</span><br><span class="line">    stackend = end_of_stack(tsk);</span><br><span class="line">    *stackend = STACK_END_MAGIC;    <span class="comment">/* for overflow detection */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CC_STACKPROTECTOR</span></span><br><span class="line">    tsk-&gt;stack_canary = get_random_int(); <span class="comment">// 金丝雀的设置，用于防御栈溢出攻击</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * One for us, one for whoever does the "release_task()" (usually</span></span><br><span class="line"><span class="comment">     * parent)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    atomic_set(&amp;tsk-&gt;usage, <span class="number">2</span>); <span class="comment">// 设置进程块的使用计数。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_BLK_DEV_IO_TRACE</span></span><br><span class="line">    tsk-&gt;btrace_seq = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    tsk-&gt;splice_pipe = <span class="literal">NULL</span>;</span><br><span class="line">    tsk-&gt;task_frag.page = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    account_kernel_stack(ti, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tsk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的代码，可以总结出fork的工作的基本流程是：</p>
<h2 id="五-do-execve的分析"><a href="#五-do-execve的分析" class="headerlink" title="五.do_execve的分析"></a>五.do_execve的分析</h2><p>execve对应的内核服务例程位于fs/exec.c中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sys_execve() 服务例程执行一个程序.</span></span><br><span class="line"><span class="comment"> * filename需要执行的文件的绝对路径</span></span><br><span class="line"><span class="comment"> * argv传入系统调用的参数</span></span><br><span class="line"><span class="comment"> * regs是系统调用时系统堆栈的情况</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_execve_common</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename,</span></span></span><br><span class="line"><span class="function"><span class="params">                struct user_arg_ptr argv,</span></span></span><br><span class="line"><span class="function"><span class="params">                struct user_arg_ptr envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">linux_binprm</span> *<span class="title">bprm</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">displaced</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> clear_in_exec;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">cred</span> = <span class="title">current_cred</span>();</span> </span><br><span class="line"></span><br><span class="line">    unshare_files(&amp;displaced); </span><br><span class="line">    <span class="comment">// 动态分配一个linux_binprm数据结构，并用新的可执行文件的数据填充这个结构</span></span><br><span class="line">    bprm = kzalloc(<span class="keyword">sizeof</span>(*bprm), GFP_KERNEL); </span><br><span class="line"></span><br><span class="line">    retval = prepare_bprm_creds(bprm);</span><br><span class="line"></span><br><span class="line">    retval = check_unsafe_exec(bprm); </span><br><span class="line">    clear_in_exec = retval;</span><br><span class="line">    current-&gt;in_execve = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    file = open_exec(filename); <span class="comment">// 打开可执行文件并读入到内存。</span></span><br><span class="line">    retval = PTR_ERR(file);</span><br><span class="line"></span><br><span class="line">    sched_exec(); <span class="comment">// 确定最小负载的CPU以执行新程序，并把当前进程转移过去。</span></span><br><span class="line"></span><br><span class="line">    bprm-&gt;file = file;</span><br><span class="line">    bprm-&gt;filename = filename;</span><br><span class="line">    bprm-&gt;interp = filename;</span><br><span class="line"></span><br><span class="line">    bprm_mm_init(bprm);</span><br><span class="line"></span><br><span class="line">    bprm-&gt;argc = count(argv, MAX_ARG_STRINGS);</span><br><span class="line"></span><br><span class="line">    bprm-&gt;envc = count(envp, MAX_ARG_STRINGS);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// prepare_binprm()填充linux_binprm数据结构，这个函数依次执行：</span></span><br><span class="line">    <span class="comment">// a.检查文件是否可执行。</span></span><br><span class="line">    <span class="comment">// b.初始化bprm的e_uid和e_gid字段。</span></span><br><span class="line">    <span class="comment">// c.用可执行文件的前128个字节填充bprm的buf字段。</span></span><br><span class="line">    prepare_binprm(bprm); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 把文件路径名拷贝、命令行参数及环境串拷贝到一个或多个新分配的页框中 */</span></span><br><span class="line">    copy_strings_kernel(<span class="number">1</span>, &amp;bprm-&gt;filename, bprm);</span><br><span class="line">    bprm-&gt;exec = bprm-&gt;p;</span><br><span class="line">    copy_strings(bprm-&gt;envc, envp, bprm);</span><br><span class="line">    copy_strings(bprm-&gt;argc, argv, bprm);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 扫描formats链表，并尽力应用每个元素的load_binary方法，把bprm传递给这个</span></span><br><span class="line">    <span class="comment">// 函数。只要load_binary方法成功应答了文件的可执行格式，对formats扫描终止。</span></span><br><span class="line">    search_binary_handler(bprm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 成功,释放bprm，返回从该文件可执行格式的load_binary方法中所获得的代码。 */</span></span><br><span class="line">    current-&gt;fs-&gt;in_exec = <span class="number">0</span>;</span><br><span class="line">    current-&gt;in_execve = <span class="number">0</span>;</span><br><span class="line">    acct_update_integrals(current);</span><br><span class="line">    free_bprm(bprm);</span><br><span class="line">    <span class="keyword">if</span> (displaced)</span><br><span class="line">        put_files_struct(displaced);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们看看load_elf_binary函数，该函数位于fs/binfmt_elf.c中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">load_elf_binary</span><span class="params">(struct linux_binprm *bprm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">interpreter</span> = <span class="title">NULL</span>;</span> <span class="comment">/* to shut gcc up */</span></span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">long</span> load_addr = <span class="number">0</span>, load_bias = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> load_addr_set = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> * elf_interpreter = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> error;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">elf_phdr</span> *<span class="title">elf_ppnt</span>, *<span class="title">elf_phdata</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> elf_bss, elf_brk;</span><br><span class="line">    <span class="keyword">int</span> retval, i;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> elf_entry;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> interp_load_addr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> start_code, end_code, start_data, end_data;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> reloc_func_desc __maybe_unused = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> executable_stack = EXSTACK_DEFAULT;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> def_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> *<span class="title">regs</span> = <span class="title">current_pt_regs</span>();</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> <span class="title">elf_ex</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> <span class="title">interp_elf_ex</span>;</span></span><br><span class="line">    &#125; *loc;</span><br><span class="line"></span><br><span class="line">    loc = kmalloc(<span class="keyword">sizeof</span>(*loc), GFP_KERNEL);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 读取可执行文件的首部。首部描述程序的段和所需的共享库。 */</span></span><br><span class="line">    loc-&gt;elf_ex = *((struct elfhdr *)bprm-&gt;buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检测一致性 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">memcmp</span>(loc-&gt;elf_ex.e_ident, ELFMAG, SELFMAG) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (loc-&gt;elf_ex.e_type != ET_EXEC &amp;&amp; loc-&gt;elf_ex.e_type != ET_DYN)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="keyword">if</span> (!elf_check_arch(&amp;loc-&gt;elf_ex))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="keyword">if</span> (!bprm-&gt;file-&gt;f_op || !bprm-&gt;file-&gt;f_op-&gt;mmap)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 读取所有的首部信息 */</span></span><br><span class="line">    loc-&gt;elf_ex.e_phentsize != <span class="keyword">sizeof</span>(struct elf_phdr);</span><br><span class="line">    <span class="keyword">if</span> (loc-&gt;elf_ex.e_phnum &lt; <span class="number">1</span> || loc-&gt;elf_ex.e_phnum &gt; <span class="number">65536U</span> / <span class="keyword">sizeof</span>(struct elf_phdr))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    size = loc-&gt;elf_ex.e_phnum * <span class="keyword">sizeof</span>(struct elf_phdr);</span><br><span class="line">    retval = -ENOMEM;</span><br><span class="line">    elf_phdata = kmalloc(size, GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    retval = kernel_read(bprm-&gt;file, loc-&gt;elf_ex.e_phoff, (<span class="keyword">char</span> *)elf_phdata, size);</span><br><span class="line">    <span class="keyword">if</span> (retval != size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (retval &gt;= <span class="number">0</span>)</span><br><span class="line">            retval = -EIO;</span><br><span class="line">        <span class="keyword">goto</span> out_free_ph;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    elf_ppnt = elf_phdata;</span><br><span class="line">    elf_bss = <span class="number">0</span>;</span><br><span class="line">    elf_brk = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    start_code = ~<span class="number">0U</span>L;</span><br><span class="line">    end_code = <span class="number">0</span>;</span><br><span class="line">    start_data = <span class="number">0</span>;</span><br><span class="line">    end_data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loc-&gt;elf_ex.e_phnum; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (elf_ppnt-&gt;p_type == PT_INTERP) &#123;</span><br><span class="line">            <span class="comment">/* This is the program interpreter used for</span></span><br><span class="line"><span class="comment">             * shared libraries - for now assume that this</span></span><br><span class="line"><span class="comment">             * is an a.out format binary</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            retval = -ENOEXEC;</span><br><span class="line">            <span class="keyword">if</span> (elf_ppnt-&gt;p_filesz &gt; PATH_MAX || </span><br><span class="line">                elf_ppnt-&gt;p_filesz &lt; <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">goto</span> out_free_ph;</span><br><span class="line"></span><br><span class="line">            retval = -ENOMEM;</span><br><span class="line">            elf_interpreter = kmalloc(elf_ppnt-&gt;p_filesz,</span><br><span class="line">                          GFP_KERNEL);</span><br><span class="line">            <span class="keyword">if</span> (!elf_interpreter)</span><br><span class="line">                <span class="keyword">goto</span> out_free_ph;</span><br><span class="line"></span><br><span class="line">            retval = kernel_read(bprm-&gt;file, elf_ppnt-&gt;p_offset,</span><br><span class="line">                         elf_interpreter,</span><br><span class="line">                         elf_ppnt-&gt;p_filesz);</span><br><span class="line">            <span class="keyword">if</span> (retval != elf_ppnt-&gt;p_filesz) &#123;</span><br><span class="line">                <span class="keyword">if</span> (retval &gt;= <span class="number">0</span>)</span><br><span class="line">                    retval = -EIO;</span><br><span class="line">                <span class="keyword">goto</span> out_free_interp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* make sure path is NULL terminated */</span></span><br><span class="line">            retval = -ENOEXEC;</span><br><span class="line">            <span class="keyword">if</span> (elf_interpreter[elf_ppnt-&gt;p_filesz - <span class="number">1</span>] != <span class="string">'\0'</span>)</span><br><span class="line">                <span class="keyword">goto</span> out_free_interp;</span><br><span class="line"></span><br><span class="line">            interpreter = open_exec(elf_interpreter);</span><br><span class="line">            retval = PTR_ERR(interpreter);</span><br><span class="line">            <span class="keyword">if</span> (IS_ERR(interpreter))</span><br><span class="line">                <span class="keyword">goto</span> out_free_interp;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * If the binary is not readable then enforce</span></span><br><span class="line"><span class="comment">             * mm-&gt;dumpable = 0 regardless of the interpreter's</span></span><br><span class="line"><span class="comment">             * permissions.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            would_dump(bprm, interpreter);</span><br><span class="line"></span><br><span class="line">            retval = kernel_read(interpreter, <span class="number">0</span>, bprm-&gt;buf,</span><br><span class="line">                         BINPRM_BUF_SIZE);</span><br><span class="line">            <span class="keyword">if</span> (retval != BINPRM_BUF_SIZE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (retval &gt;= <span class="number">0</span>)</span><br><span class="line">                    retval = -EIO;</span><br><span class="line">                <span class="keyword">goto</span> out_free_dentry;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Get the exec headers */</span></span><br><span class="line">            loc-&gt;interp_elf_ex = *((struct elfhdr *)bprm-&gt;buf);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        elf_ppnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    elf_ppnt = elf_phdata;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loc-&gt;elf_ex.e_phnum; i++, elf_ppnt++)</span><br><span class="line">        <span class="keyword">if</span> (elf_ppnt-&gt;p_type == PT_GNU_STACK) &#123;</span><br><span class="line">            <span class="keyword">if</span> (elf_ppnt-&gt;p_flags &amp; PF_X)</span><br><span class="line">                executable_stack = EXSTACK_ENABLE_X;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                executable_stack = EXSTACK_DISABLE_X;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Some simple consistency checks for the interpreter */</span></span><br><span class="line">    <span class="keyword">if</span> (elf_interpreter) &#123;</span><br><span class="line">        retval = -ELIBBAD;</span><br><span class="line">        <span class="comment">/* Not an ELF interpreter */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">memcmp</span>(loc-&gt;interp_elf_ex.e_ident, ELFMAG, SELFMAG) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> out_free_dentry;</span><br><span class="line">        <span class="comment">/* Verify the interpreter has a valid arch */</span></span><br><span class="line">        <span class="keyword">if</span> (!elf_check_arch(&amp;loc-&gt;interp_elf_ex))</span><br><span class="line">            <span class="keyword">goto</span> out_free_dentry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放前一个计算所占用的几乎所有资源</span></span><br><span class="line">    retval = flush_old_exec(bprm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* OK, This is the point of no return */</span></span><br><span class="line">    current-&gt;mm-&gt;def_flags = def_flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Do this immediately, since STACK_TOP as used in setup_arg_pages</span></span><br><span class="line"><span class="comment">       may depend on the personality.  */</span></span><br><span class="line">    SET_PERSONALITY(loc-&gt;elf_ex);</span><br><span class="line">    <span class="keyword">if</span> (elf_read_implies_exec(loc-&gt;elf_ex, executable_stack))</span><br><span class="line">        current-&gt;personality |= READ_IMPLIES_EXEC;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(current-&gt;personality &amp; ADDR_NO_RANDOMIZE) &amp;&amp; randomize_va_space)</span><br><span class="line">        current-&gt;flags |= PF_RANDOMIZE;</span><br><span class="line"></span><br><span class="line">    setup_new_exec(bprm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Do this so that we can load the interpreter, if need be.  We will</span></span><br><span class="line"><span class="comment">       change some of these later */</span></span><br><span class="line">    current-&gt;mm-&gt;free_area_cache = current-&gt;mm-&gt;mmap_base;</span><br><span class="line">    current-&gt;mm-&gt;cached_hole_size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 为进程的用户态堆栈分配一个新的线性区描述符，并把那个线性区插入到进程的地址空间。</span></span><br><span class="line">    setup_arg_pages(bprm, randomize_stack_top(STACK_TOP), executable_stack);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    current-&gt;mm-&gt;start_stack = bprm-&gt;p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 现在将ELF镜像文件映射到内存中正确的位置 */</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>, elf_ppnt = elf_phdata;</span><br><span class="line">        i &lt; loc-&gt;elf_ex.e_phnum; i++, elf_ppnt++) &#123;</span><br><span class="line">        <span class="keyword">int</span> elf_prot = <span class="number">0</span>, elf_flags;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> k, vaddr;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (elf_ppnt-&gt;p_type != PT_LOAD)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unlikely (elf_brk &gt; elf_bss)) &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> nbyte;</span><br><span class="line">                </span><br><span class="line">            <span class="comment">/* There was a PT_LOAD segment with p_memsz &gt; p_filesz</span></span><br><span class="line"><span class="comment">               before this one. Map anonymous pages, if needed,</span></span><br><span class="line"><span class="comment">               and clear the area.  */</span></span><br><span class="line">            retval = set_brk(elf_bss + load_bias,</span><br><span class="line">                     elf_brk + load_bias);</span><br><span class="line">            <span class="keyword">if</span> (retval) &#123;</span><br><span class="line">                send_sig(SIGKILL, current, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">goto</span> out_free_dentry;</span><br><span class="line">            &#125;</span><br><span class="line">            nbyte = ELF_PAGEOFFSET(elf_bss);</span><br><span class="line">            <span class="keyword">if</span> (nbyte) &#123;</span><br><span class="line">                nbyte = ELF_MIN_ALIGN - nbyte;</span><br><span class="line">                <span class="keyword">if</span> (nbyte &gt; elf_brk - elf_bss)</span><br><span class="line">                    nbyte = elf_brk - elf_bss;</span><br><span class="line">                <span class="keyword">if</span> (clear_user((<span class="keyword">void</span> __user *)elf_bss +</span><br><span class="line">                            load_bias, nbyte)) &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * This bss-zeroing can fail if the ELF</span></span><br><span class="line"><span class="comment">                     * file specifies odd protections. So</span></span><br><span class="line"><span class="comment">                     * we don't check the return value</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (elf_ppnt-&gt;p_flags &amp; PF_R)</span><br><span class="line">            elf_prot |= PROT_READ;</span><br><span class="line">        <span class="keyword">if</span> (elf_ppnt-&gt;p_flags &amp; PF_W)</span><br><span class="line">            elf_prot |= PROT_WRITE;</span><br><span class="line">        <span class="keyword">if</span> (elf_ppnt-&gt;p_flags &amp; PF_X)</span><br><span class="line">            elf_prot |= PROT_EXEC;</span><br><span class="line"></span><br><span class="line">        elf_flags = MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE;</span><br><span class="line"></span><br><span class="line">        vaddr = elf_ppnt-&gt;p_vaddr;</span><br><span class="line">        <span class="keyword">if</span> (loc-&gt;elf_ex.e_type == ET_EXEC || load_addr_set) &#123;</span><br><span class="line">            elf_flags |= MAP_FIXED;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (loc-&gt;elf_ex.e_type == ET_DYN) &#123;</span><br><span class="line">            <span class="comment">/* Try and get dynamic programs out of the way of the</span></span><br><span class="line"><span class="comment">             * default mmap base, as well as whatever program they</span></span><br><span class="line"><span class="comment">             * might try to exec.  This is because the brk will</span></span><br><span class="line"><span class="comment">             * follow the loader, and is not movable.  */</span></span><br><span class="line">#ifdef CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE</span><br><span class="line">            <span class="comment">/* Memory randomization might have been switched off</span></span><br><span class="line"><span class="comment">             * in runtime via sysctl.</span></span><br><span class="line"><span class="comment">             * If that is the case, retain the original non-zero</span></span><br><span class="line"><span class="comment">             * load_bias value in order to establish proper</span></span><br><span class="line"><span class="comment">             * non-randomized mappings.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (current-&gt;flags &amp; PF_RANDOMIZE)</span><br><span class="line">                load_bias = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                load_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            load_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error = elf_map(bprm-&gt;file, load_bias + vaddr, elf_ppnt,</span><br><span class="line">                elf_prot, elf_flags, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (BAD_ADDR(error)) &#123;</span><br><span class="line">            send_sig(SIGKILL, current, <span class="number">0</span>);</span><br><span class="line">            retval = IS_ERR((<span class="keyword">void</span> *)error) ?</span><br><span class="line">                PTR_ERR((<span class="keyword">void</span>*)error) : -EINVAL;</span><br><span class="line">            <span class="keyword">goto</span> out_free_dentry;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!load_addr_set) &#123;</span><br><span class="line">            load_addr_set = <span class="number">1</span>;</span><br><span class="line">            load_addr = (elf_ppnt-&gt;p_vaddr - elf_ppnt-&gt;p_offset);</span><br><span class="line">            <span class="keyword">if</span> (loc-&gt;elf_ex.e_type == ET_DYN) &#123;</span><br><span class="line">                load_bias += error -</span><br><span class="line">                             ELF_PAGESTART(load_bias + vaddr);</span><br><span class="line">                load_addr += load_bias;</span><br><span class="line">                reloc_func_desc = load_bias;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        k = elf_ppnt-&gt;p_vaddr;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; start_code)</span><br><span class="line">            start_code = k;</span><br><span class="line">        <span class="keyword">if</span> (start_data &lt; k)</span><br><span class="line">            start_data = k;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Check to see if the section's size will overflow the</span></span><br><span class="line"><span class="comment">         * allowed task size. Note that p_filesz must always be</span></span><br><span class="line"><span class="comment">         * &lt;= p_memsz so it is only necessary to check p_memsz.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (BAD_ADDR(k) || elf_ppnt-&gt;p_filesz &gt; elf_ppnt-&gt;p_memsz ||</span><br><span class="line">            elf_ppnt-&gt;p_memsz &gt; TASK_SIZE ||</span><br><span class="line">            TASK_SIZE - elf_ppnt-&gt;p_memsz &lt; k) &#123;</span><br><span class="line">            <span class="comment">/* set_brk can never work. Avoid overflows. */</span></span><br><span class="line">            send_sig(SIGKILL, current, <span class="number">0</span>);</span><br><span class="line">            retval = -EINVAL;</span><br><span class="line">            <span class="keyword">goto</span> out_free_dentry;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        k = elf_ppnt-&gt;p_vaddr + elf_ppnt-&gt;p_filesz;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k &gt; elf_bss)</span><br><span class="line">            elf_bss = k;</span><br><span class="line">        <span class="keyword">if</span> ((elf_ppnt-&gt;p_flags &amp; PF_X) &amp;&amp; end_code &lt; k)</span><br><span class="line">            end_code = k;</span><br><span class="line">        <span class="keyword">if</span> (end_data &lt; k)</span><br><span class="line">            end_data = k;</span><br><span class="line">        k = elf_ppnt-&gt;p_vaddr + elf_ppnt-&gt;p_memsz;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; elf_brk)</span><br><span class="line">            elf_brk = k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    loc-&gt;elf_ex.e_entry += load_bias;</span><br><span class="line">    elf_bss += load_bias;</span><br><span class="line">    elf_brk += load_bias;</span><br><span class="line">    start_code += load_bias;</span><br><span class="line">    end_code += load_bias;</span><br><span class="line">    start_data += load_bias;</span><br><span class="line">    end_data += load_bias;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Calling set_brk effectively mmaps the pages that we need</span></span><br><span class="line"><span class="comment">     * for the bss and break sections.  We must do this before</span></span><br><span class="line"><span class="comment">     * mapping in the interpreter, to make sure it doesn't wind</span></span><br><span class="line"><span class="comment">     * up getting placed where the bss needs to go.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    retval = set_brk(elf_bss, elf_brk);</span><br><span class="line">    <span class="keyword">if</span> (retval) &#123;</span><br><span class="line">        send_sig(SIGKILL, current, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">goto</span> out_free_dentry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (likely(elf_bss != elf_brk) &amp;&amp; unlikely(padzero(elf_bss))) &#123;</span><br><span class="line">        send_sig(SIGSEGV, current, <span class="number">0</span>);</span><br><span class="line">        retval = -EFAULT; <span class="comment">/* Nobody gets to see this, but.. */</span></span><br><span class="line">        <span class="keyword">goto</span> out_free_dentry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用一个动态链接程序的函数。如果动态链接程序是elf可执行的，这</span></span><br><span class="line">    <span class="comment">// 个函数就叫做load_elf_interp()。</span></span><br><span class="line">    <span class="keyword">if</span> (elf_interpreter) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> interp_map_addr = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        elf_entry = load_elf_interp(&amp;loc-&gt;interp_elf_ex,</span><br><span class="line">                        interpreter,</span><br><span class="line">                        &amp;interp_map_addr,</span><br><span class="line">                        load_bias);</span><br><span class="line">        <span class="keyword">if</span> (!IS_ERR((<span class="keyword">void</span> *)elf_entry)) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * load_elf_interp() returns relocation</span></span><br><span class="line"><span class="comment">             * adjustment</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            interp_load_addr = elf_entry;</span><br><span class="line">            elf_entry += loc-&gt;interp_elf_ex.e_entry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (BAD_ADDR(elf_entry)) &#123;</span><br><span class="line">            force_sig(SIGSEGV, current);</span><br><span class="line">            retval = IS_ERR((<span class="keyword">void</span> *)elf_entry) ?</span><br><span class="line">                    (<span class="keyword">int</span>)elf_entry : -EINVAL;</span><br><span class="line">            <span class="keyword">goto</span> out_free_dentry;</span><br><span class="line">        &#125;</span><br><span class="line">        reloc_func_desc = interp_load_addr;</span><br><span class="line"></span><br><span class="line">        allow_write_access(interpreter);</span><br><span class="line">        fput(interpreter);</span><br><span class="line">        kfree(elf_interpreter);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        elf_entry = loc-&gt;elf_ex.e_entry;</span><br><span class="line">        <span class="keyword">if</span> (BAD_ADDR(elf_entry)) &#123;</span><br><span class="line">            force_sig(SIGSEGV, current);</span><br><span class="line">            retval = -EINVAL;</span><br><span class="line">            <span class="keyword">goto</span> out_free_dentry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kfree(elf_phdata);</span><br><span class="line">    <span class="comment">// 把可执行格式的linux_binfmt对象的地址存放在进程描述符的binfmt字段中。</span></span><br><span class="line">    set_binfmt(&amp;elf_format);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ARCH_HAS_SETUP_ADDITIONAL_PAGES</span></span><br><span class="line">    retval = arch_setup_additional_pages(bprm, !!elf_interpreter);</span><br><span class="line">    <span class="keyword">if</span> (retval &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        send_sig(SIGKILL, current, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ARCH_HAS_SETUP_ADDITIONAL_PAGES */</span></span></span><br><span class="line"></span><br><span class="line">    install_exec_creds(bprm);</span><br><span class="line">    retval = create_elf_tables(bprm, &amp;loc-&gt;elf_ex,</span><br><span class="line">              load_addr, interp_load_addr);</span><br><span class="line">    <span class="keyword">if</span> (retval &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        send_sig(SIGKILL, current, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* N.B. passed_fileno might not be initialized? */</span></span><br><span class="line">    current-&gt;mm-&gt;end_code = end_code;</span><br><span class="line">    current-&gt;mm-&gt;start_code = start_code;</span><br><span class="line">    current-&gt;mm-&gt;start_data = start_data;</span><br><span class="line">    current-&gt;mm-&gt;end_data = end_data;</span><br><span class="line">    current-&gt;mm-&gt;start_stack = bprm-&gt;p;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> arch_randomize_brk</span></span><br><span class="line">    <span class="keyword">if</span> ((current-&gt;flags &amp; PF_RANDOMIZE) &amp;&amp; (randomize_va_space &gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        current-&gt;mm-&gt;brk = current-&gt;mm-&gt;start_brk =</span><br><span class="line">            arch_randomize_brk(current-&gt;mm);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_COMPAT_BRK</span></span><br><span class="line">        current-&gt;brk_randomized = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current-&gt;personality &amp; MMAP_PAGE_ZERO) &#123;</span><br><span class="line">        <span class="comment">/* Why this, you ask???  Well SVr4 maps page 0 as read-only,</span></span><br><span class="line"><span class="comment">           and some applications "depend" upon this behavior.</span></span><br><span class="line"><span class="comment">           Since we do not have the power to recompile these, we</span></span><br><span class="line"><span class="comment">           emulate the SVr4 behavior. Sigh. */</span></span><br><span class="line">        error = vm_mmap(<span class="literal">NULL</span>, <span class="number">0</span>, PAGE_SIZE, PROT_READ | PROT_EXEC,</span><br><span class="line">                MAP_FIXED | MAP_PRIVATE, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ELF_PLAT_INIT</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The ABI may specify that certain registers be set up in special</span></span><br><span class="line"><span class="comment">     * ways (on i386 %edx is the address of a DT_FINI function, for</span></span><br><span class="line"><span class="comment">     * example.  In addition, it may also specify (eg, PowerPC64 ELF)</span></span><br><span class="line"><span class="comment">     * that the e_entry field is the address of the function descriptor</span></span><br><span class="line"><span class="comment">     * for the startup routine, rather than the address of the startup</span></span><br><span class="line"><span class="comment">     * routine itself.  This macro performs whatever initialization to</span></span><br><span class="line"><span class="comment">     * the regs structure is required as well as any relocations to the</span></span><br><span class="line"><span class="comment">     * function descriptor entries when executing dynamically links apps.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ELF_PLAT_INIT(regs, reloc_func_desc);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    start_thread(regs, elf_entry, bprm-&gt;p);</span><br><span class="line">    retval = <span class="number">0</span>;</span><br><span class="line">out:</span><br><span class="line">    kfree(loc);</span><br><span class="line">out_ret:</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* error cleanup */</span></span><br><span class="line">out_free_dentry:</span><br><span class="line">    allow_write_access(interpreter);</span><br><span class="line">    <span class="keyword">if</span> (interpreter)</span><br><span class="line">        fput(interpreter);</span><br><span class="line">out_free_interp:</span><br><span class="line">    kfree(elf_interpreter);</span><br><span class="line">out_free_ph:</span><br><span class="line">    kfree(elf_phdata);</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  </div>
</article>



  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="http://github.com/amendgit">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一-关于fork调用"><span class="toc-number">1.</span> <span class="toc-text">一. 关于fork调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二-关于execl调用"><span class="toc-number">2.</span> <span class="toc-text">二. 关于execl调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三-使用汇编进行系统调用"><span class="toc-number">3.</span> <span class="toc-text">三. 使用汇编进行系统调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四-系统调用过程详解"><span class="toc-number">4.</span> <span class="toc-text">四.系统调用过程详解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四-do-fork源码分析"><span class="toc-number">5.</span> <span class="toc-text">四.do_fork源码分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五-do-execve的分析"><span class="toc-number">6.</span> <span class="toc-text">五.do_execve的分析</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://www.amendgit.com/2017/linux-understand-process/"><i class="fa fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://www.amendgit.com/2017/linux-understand-process/&text=深入理解Linux之进程初探"><i class="fa fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://www.amendgit.com/2017/linux-understand-process/&title=深入理解Linux之进程初探"><i class="fa fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://www.amendgit.com/2017/linux-understand-process/&is_video=false&description=深入理解Linux之进程初探"><i class="fa fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=深入理解Linux之进程初探&body=Check out this article: http://www.amendgit.com/2017/linux-understand-process/"><i class="fa fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://www.amendgit.com/2017/linux-understand-process/&title=深入理解Linux之进程初探"><i class="fa fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://www.amendgit.com/2017/linux-understand-process/&title=深入理解Linux之进程初探"><i class="fa fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://www.amendgit.com/2017/linux-understand-process/&title=深入理解Linux之进程初探"><i class="fa fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://www.amendgit.com/2017/linux-understand-process/&title=深入理解Linux之进程初探"><i class="fa fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://www.amendgit.com/2017/linux-understand-process/&name=深入理解Linux之进程初探&description="><i class="fa fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
      <ul>
        <li id="toc"><a class="icon" href="#" onclick='$("#toc-footer").toggle();return false;'><i class="fa fa-list fa-lg" aria-hidden="true"></i> TOC</a></li>
        <li id="share"><a class="icon" href="#" onclick='$("#share-footer").toggle();return false;'><i class="fa fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></li>
        <li id="top" style="display:none"><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></li>
        <li id="menu"><a class="icon" href="#" onclick='$("#nav-footer").toggle();return false;'><i class="fa fa-bars fa-lg" aria-hidden="true"></i> Menu</a></li>
      </ul>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2018 amendgit
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="http://github.com/amendgit">Projects</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

</body>
</html>

<!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
<link rel="stylesheet" href="/lib/meslo-LG/styles.css">
<link rel="stylesheet" href="/lib/justified-gallery/justifiedGallery.min.css">


<!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>
<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-86660611-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Disqus Comments -->


