<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Leetcode Solutions 021 040 - amendgit`s blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="amendgit" />
  <meta name="description" content="本文用来记录我的leetcode解题报告，用于之后的代码优化、查阅和复习。这里是第21题到第40题。

" />

  <meta name="keywords" content="amendgit, blog" />






<meta name="generator" content="Hugo 0.46" />


<link rel="canonical" href="http://localhost:1313/post/leetcode/leetcode-solutions-021-040/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">







<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="Leetcode Solutions 021 040" />
<meta property="og:description" content="本文用来记录我的leetcode解题报告，用于之后的代码优化、查阅和复习。这里是第21题到第40题。

" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/post/leetcode/leetcode-solutions-021-040/" />



<meta property="article:published_time" content="2018-07-01T11:33:03&#43;08:00"/>

<meta property="article:modified_time" content="2018-07-01T11:33:03&#43;08:00"/>











<meta itemprop="name" content="Leetcode Solutions 021 040">
<meta itemprop="description" content="本文用来记录我的leetcode解题报告，用于之后的代码优化、查阅和复习。这里是第21题到第40题。

">


<meta itemprop="datePublished" content="2018-07-01T11:33:03&#43;08:00" />
<meta itemprop="dateModified" content="2018-07-01T11:33:03&#43;08:00" />
<meta itemprop="wordCount" content="4506">



<meta itemprop="keywords" content="leetcode," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Leetcode Solutions 021 040"/>
<meta name="twitter:description" content="本文用来记录我的leetcode解题报告，用于之后的代码优化、查阅和复习。这里是第21题到第40题。

"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">amendgit&#39;s blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">amendgit&#39;s blog</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Leetcode Solutions 021 040</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-07-01 </span>
        
        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#21-merge-two-sorted-lists">21. Merge Two Sorted Lists</a></li>
<li><a href="#22-generate-parentheses">22. Generate Parentheses</a></li>
<li><a href="#23-merge-k-sorted-lists">23. Merge k Sorted Lists</a></li>
<li><a href="#24-swap-nodes-in-pairs">24. Swap Nodes in Pairs</a></li>
<li><a href="#25-reverse-nodes-in-k-group">25. Reverse Nodes in k-Group</a></li>
<li><a href="#26-remove-duplicates-from-sorted-array">26. Remove Duplicates from Sorted Array</a></li>
<li><a href="#27-remove-element">27. Remove Element</a></li>
<li><a href="#28-implement-strstr">28. Implement strStr()</a></li>
<li><a href="#29-divide-two-integers">29. Divide Two Integers</a></li>
<li><a href="#30-substring-with-concatenation-of-all-words">30. Substring with Concatenation of All Words</a></li>
<li><a href="#31-next-permutation">31. Next Permutation</a></li>
<li><a href="#32-longest-valid-parentheses">32. Longest Valid Parentheses</a></li>
<li><a href="#33-search-in-rotated-sorted-array">33. Search in Rotated Sorted Array</a></li>
<li><a href="#34-search-for-a-range">34. Search for a Range</a></li>
<li><a href="#35-search-insert-position">35. Search Insert Position</a></li>
<li><a href="#36-valid-sudoku">36 Valid Sudoku</a></li>
<li><a href="#37-sodoku-solver">37. Sodoku Solver</a></li>
<li><a href="#38-count-and-say">38. Count and Say</a></li>
<li><a href="#39-combination-sum">39. Combination Sum</a></li>
<li><a href="#40-combination-sum-ii">40. Combination Sum II</a></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    

    
    <div class="post-content">
      <p>本文用来记录我的leetcode解题报告，用于之后的代码优化、查阅和复习。这里是第21题到第40题。</p>

<p></p>

<h2 id="21-merge-two-sorted-lists">21. Merge Two Sorted Lists</h2>

<p>链接：<a href="https://leetcode.com/problems/merge-two-sorted-lists/#/description">https://leetcode.com/problems/merge-two-sorted-lists/#/description</a>
使用优先级队列解决该问题</p>

<pre><code class="language-cpp">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        struct NodeGreater { bool operator()(ListNode *lhs, ListNode *rhs) { return lhs-&gt;val &gt; rhs-&gt;val; } };
        priority_queue&lt;ListNode *, vector&lt;ListNode *&gt;, NodeGreater&gt; q;
        if (l1) q.push(l1); if (l2) q.push(l2);
        ListNode dummy = ListNode(0); ListNode *p = &amp;dummy;
        while (!q.empty()) {
            ListNode *tmp = q.top(); q.pop();
            if (tmp-&gt;next) q.push(tmp-&gt;next);
            p-&gt;next = tmp; p = p-&gt;next;
        }
        p-&gt;next = nullptr;
        return dummy.next;
    }
};
</code></pre>

<h2 id="22-generate-parentheses">22. Generate Parentheses</h2>

<p>链接：<a href="https://leetcode.com/problems/generate-parentheses/#/description">https://leetcode.com/problems/generate-parentheses/#/description</a></p>

<pre><code class="language-cpp">class Solution {
public:
    vector&lt;string&gt; generateParenthesis(int n) {
        vector&lt;string&gt; result; string path;
        generateParenthesis(0, 0, n, path, result);
        return move(result);
    }
    
    void generateParenthesis(int o, int c, int n, string &amp;path, vector&lt;string&gt;&amp; result) {
        if (o + c == n*2) { result.push_back(path); return; }
        
        if (o &lt; n) { 
            path.push_back('('); generateParenthesis(o+1, c, n, path, result); path.pop_back(); 
        }
        
        if (o &gt; c &amp;&amp; c &lt; n) { 
            path.push_back(')'); generateParenthesis(o, c+1, n, path, result); path.pop_back(); 
        }
    }
};
</code></pre>

<h2 id="23-merge-k-sorted-lists">23. Merge k Sorted Lists</h2>

<p>链接：<a href="https://leetcode.com/problems/merge-k-sorted-lists/">https://leetcode.com/problems/merge-k-sorted-lists/</a>
思路：
1. 优先级队列，压入每个链表当前节点.
2. 取出最小节点，组成新链表，压入该节点的非空next.
3. 队列为空时结束.</p>

<pre><code class="language-cpp">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) {
        struct NodeGreater { bool operator()(ListNode *lhs, ListNode *rhs) { 
            return lhs-&gt;val &gt; rhs-&gt;val; 
        } };
        priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, NodeGreater&gt; q;
        for (auto node : lists) if (node) q.push(node); 
        ListNode dummy(0), *p = &amp;dummy; p-&gt;next = nullptr;
        while (!q.empty()) {
            ListNode *node = q.top(); q.pop();
            p-&gt;next = node; p = p-&gt;next;
            if (node-&gt;next) q.push(node-&gt;next);
        }
        return dummy.next;
    }
};
</code></pre>

<h2 id="24-swap-nodes-in-pairs">24. Swap Nodes in Pairs</h2>

<p>链接： <a href="https://leetcode.com/problems/swap-nodes-in-pairs/#/description">https://leetcode.com/problems/swap-nodes-in-pairs/#/description</a></p>

<pre><code class="language-cpp">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode dummy(0); dummy.next = head;
        ListNode *p = &amp;dummy, *a, *b, *tmp;
        while (true) {
            if (p-&gt;next) a = p-&gt;next; else break;
            if (a-&gt;next) b = a-&gt;next; else break;
            tmp = b-&gt;next;
            b-&gt;next = a; a-&gt;next = tmp; p-&gt;next = b;
            p = a;
        }
        return dummy.next;
    }
};
</code></pre>

<h2 id="25-reverse-nodes-in-k-group">25. Reverse Nodes in k-Group</h2>

<p>链接：<a href="https://leetcode.com/problems/reverse-nodes-in-k-group/#/description">https://leetcode.com/problems/reverse-nodes-in-k-group/#/description</a></p>

<pre><code class="language-cpp">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        if (k == 1) return head;
        ListNode dummy(0); dummy.next = head;
        ListNode *p = &amp;dummy, *q, *hold, *first, *last;
        while (true) {
            q = p;
            for (int i = 0; i &lt; k; ++i) if (q &amp;&amp; q-&gt;next) q = q-&gt;next; else return dummy.next;
            hold = q-&gt;next; q-&gt;next = nullptr;
            reverseList(p-&gt;next, &amp;first, &amp;last);
            p-&gt;next = first; last-&gt;next = hold; p = last;
        }
        
        return dummy.next;
    }
    
    void reverseList(ListNode *head, ListNode **first, ListNode **last) {
        static ListNode dummy(0); dummy.next = head; 
        ListNode *a = &amp;dummy, *b = a-&gt;next, *c = nullptr;
        while (b) { c = b-&gt;next; b-&gt;next = a; a = b; b = c; }
        *first = a; *last = head; head-&gt;next = nullptr;
    }
};
</code></pre>

<h2 id="26-remove-duplicates-from-sorted-array">26. Remove Duplicates from Sorted Array</h2>

<p>链接：<a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/#/description">https://leetcode.com/problems/remove-duplicates-from-sorted-array/#/description</a></p>

<pre><code class="language-cpp">class Solution {
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) {
        auto len = nums.size();
        if (len &lt;= 1) return len;
        int last = nums[0], i = 1, j = 1;
        while (j &lt; len) {
            if (nums[j] != last) { nums[i++] = nums[j]; last = nums[j]; }
            j++;
        }
        return i;
    }
};
</code></pre>

<h2 id="27-remove-element">27. Remove Element</h2>

<p>链接：<a href="https://leetcode.com/problems/remove-element/#/description">https://leetcode.com/problems/remove-element/#/description</a></p>

<pre><code class="language-cpp">class Solution {
public:
    int removeElement(vector&lt;int&gt;&amp; nums, int val) {
        int i = 0, j = 0;
        for (j = 0; j &lt; nums.size(); j++) {
            if (nums[j] == val) continue;
            nums[i++] = nums[j];
        }
        return i;
    }
};
</code></pre>

<h2 id="28-implement-strstr">28. Implement strStr()</h2>

<p>链接：<a href="https://leetcode.com/problems/implement-strstr/#/description">https://leetcode.com/problems/implement-strstr/#/description</a>
思路：暴力求解
耗时3ms</p>

<pre><code class="language-cpp">class Solution {
public:
    int strStr(const string &amp;haystack, const string &amp;needle) {
        int lenH = haystack.length(), lenN = needle.length();
        if (lenH &lt; lenN) return -1;
        for (int i = 0; i &lt;= lenH - lenN; i++) {
            bool eq = true;
            for (int j = 0; j &lt; lenN; j++) 
                if (haystack[i+j] != needle[j]) { eq = false; break; }
            if (eq) return i;
        }
        return -1;
    }
};
</code></pre>

<h2 id="29-divide-two-integers">29. Divide Two Integers</h2>

<p>链接：<a href="https://leetcode.com/problems/divide-two-integers/">https://leetcode.com/problems/divide-two-integers/</a>
思路：</p>

<ul>
<li>unsigned int(0 ~ 4294967295), INT_MIN(-2147483648), INT_MAX(2147483647)。</li>
<li>INT_MAX的二进制表示为：0111 1111 1111 1111 1111 1111 1111 1111</li>
<li>INT_MIN的二进制表示为：1000 0000 0000 0000 0000 0000 0000 0000</li>
<li>int型最高为为符号位，0正1负。CPU眼中只有数值，INT_MAX + 1 == INT_MIN。</li>
<li>unsigned int最大表示： 1111 1111 1111 1111 1111 1111 1111 1111</li>
<li>unsigned int可以防止转换为正数时溢出。</li>
<li>当unsigned int值为-INT_MIN(2147483648)再左移会溢出。</li>
<li>+ 比 &lt;&lt; 优先级要高，详见：<a href="http://www.jb51.net/article/37282.htm">http://www.jb51.net/article/37282.htm</a></li>
</ul>

<pre><code class="language-cpp">class Solution {
public:
    int divide(int dividend, int divisor) {
        long long a = dividend&gt;=0 ? dividend : -(long long)dividend;
        long long b = divisor&gt;=0  ? divisor  : -(long long)divisor;
        long long r = 0; int i = 0;
        while (b&lt;&lt;1 &lt; a) { i++; b&lt;&lt;=1; };
        while (a&gt;=b || i&gt;0) {
            a -= b; r += 1&lt;&lt;i;
            while (a &lt; b &amp;&amp; i &gt; 0) { i--; b&gt;&gt;=1; }
        }
        if ((dividend^divisor)&gt;&gt;31) r = -r;
        else if (r &gt; INT_MAX)       r = INT_MAX;
        return r;
    }
};
</code></pre>

<pre><code class="language-cpp">class Solution {
public:
    int divide(int dividend, int divisor) {
        unsigned int a = dividend&gt;=0 ? dividend : -dividend;
        unsigned int b = divisor&gt;=0  ? divisor  : -divisor;
        int r=0; long long bb; int i;
        while (a &gt;= b) for (i=0, bb=b; a &gt;= bb; i++, bb&lt;&lt;=1) {
            a -= bb; r += 1&lt;&lt;i;
        }
        if      ((dividend^divisor)&gt;&gt;31)     r = -r;
        else if ((unsigned int)r &gt; INT_MAX)  r = INT_MAX;
        return r;
    }
};
</code></pre>

<h2 id="30-substring-with-concatenation-of-all-words">30. Substring with Concatenation of All Words</h2>

<p>链接：<a href="https://leetcode.com/problems/substring-with-concatenation-of-all-words/#/description">https://leetcode.com/problems/substring-with-concatenation-of-all-words/#/description</a></p>

<p>思路：用的map，耗时206ms，超过45%</p>

<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; findSubstring(const string&amp; s, vector&lt;string&gt;&amp; words) {
        map&lt;string, int&gt; tbl; map&lt;string, int&gt; vst;
        vector&lt;int&gt; result;
        if (words.empty()) return result;
        int lenW = words[0].length(), lenT = words.size() * lenW, lenS = s.length();
        if (s.size() &lt; lenT) return result;
        for (auto &amp;word : words) tbl[word] = tbl.find(word) == tbl.end() ? 1 : tbl[word]+1;
        for (int i = 0; i &lt;= lenS - lenT; i++) {
            string tar = s.substr(i, lenW);
            if (tbl.find(tar) != tbl.end()) {
                int fnd = 1;
                vst[tar] = 1;
                for (int j = lenW; j &lt; lenT; j += lenW) {
                    tar = s.substr(i+j, lenW);
                    if (tbl.find(tar) != tbl.end()) {
                        vst[tar] = vst.find(tar) == vst.end() ? 1 : vst[tar]+1;
                        if (tbl[tar] &gt;= vst[tar]) fnd++; else break;
                    } else break;
                }
                vst.clear();
                if (fnd == words.size()) result.push_back(i);
            }
        }
        return result;
    }
};
</code></pre>

<p>用unorderd_map试试，好像还慢了一些，299ms，击败24%</p>

<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; findSubstring(const string&amp; s, vector&lt;string&gt;&amp; words) {
        unordered_map&lt;string, int&gt; tbl; unordered_map&lt;string, int&gt; vst;
        vector&lt;int&gt; result;
        if (words.empty()) return result;
        int lenW = words[0].length(), lenT = words.size() * lenW, lenS = s.length();
        if (s.size() &lt; lenT) return result;
        for (auto &amp;word : words) tbl[word] = tbl.find(word) == tbl.end() ? 1 : tbl[word]+1;
        for (int i = 0; i &lt;= lenS - lenT; i++) {
            string tar = s.substr(i, lenW);
            if (tbl.find(tar) != tbl.end()) {
                int fnd = 1;
                vst[tar] = 1;
                for (int j = lenW; j &lt; lenT; j += lenW) {
                    tar = s.substr(i+j, lenW);
                    if (tbl.find(tar) != tbl.end()) {
                        vst[tar] = vst.find(tar) == vst.end() ? 1 : vst[tar]+1;
                        if (tbl[tar] &gt;= vst[tar]) fnd++; else break;
                    } else {
                        break;
                    }
                }
                vst.clear();
                if (fnd == words.size()) result.push_back(i);
            }
        }
        return result;
    }
};
</code></pre>

<p>用unordered_multiset，直接超时。</p>

<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; findSubstring(const string&amp; s, vector&lt;string&gt;&amp; words) {
        unordered_multiset&lt;string&gt; tbl; unordered_multiset&lt;string&gt; vst;
        vector&lt;int&gt; result;
        if (words.empty()) return result;
        int lenW = words[0].length(), lenT = words.size() * lenW, lenS = s.length();
        if (s.size() &lt; lenT) return result;
        for (auto &amp;word : words) tbl.insert(word);
        for (int i = 0; i &lt;= lenS-lenT; i++) {
            string tar = s.substr(i, lenW);
            if (tbl.find(tar) != tbl.end()) {
                int fnd = 1;
                vst.insert(tar);
                for (int j = lenW; j &lt; lenT; j += lenW) {
                    tar = s.substr(i+j, lenW);
                    if (tbl.find(tar) != tbl.end() &amp;&amp; tbl.count(tar) &gt; vst.count(tar)) {
                        vst.insert(tar);
                        fnd++;
                    } else {
                        break;
                    }
                }
                vst.clear();
                if (fnd == words.size()) result.push_back(i);
            }
        }
        return result;
    }
};
</code></pre>

<p>貌似还有O(n)的解法，没想出来。</p>

<h2 id="31-next-permutation">31. Next Permutation</h2>

<p>链接：<a href="https://leetcode.com/problems/next-permutation/">https://leetcode.com/problems/next-permutation/</a>
思路：
1. 从尾部开始找到第一个不满足逆序序列的元素i
2. 在逆序序列中找到最接近的较小元素j
3. 交换i和j，并将逆序序列反置</p>

<pre><code class="language-cpp">class Solution {
public:
    void nextPermutation(vector&lt;int&gt;&amp; nums) {
        int i=0, j=0, len=nums.size();
        i=len-2; while (i&gt;=0 &amp;&amp; nums[i+1]&lt;=nums[i]) --i;
        if (i == -1) { reverse(nums.begin(), nums.end()); return; }
        j=len-1; while (j&gt;i &amp;&amp; nums[i]&gt;=nums[j]) --j;
        swap(nums[i], nums[j]);
        reverse(nums.begin()+i+1, nums.end());
    }
};
</code></pre>

<h2 id="32-longest-valid-parentheses">32. Longest Valid Parentheses</h2>

<p>链接：<a href="https://leetcode.com/problems/longest-valid-parentheses/">https://leetcode.com/problems/longest-valid-parentheses/</a>
思路：动态规划，有效的括号序列是由多个单有效括号序列组成的：(&hellip;)(&hellip;)(&hellip;) 。设f[i]表示以i为结束位置的最长有效括号序列的长度，则当[l,i]有效时f[i] = f[l-1] + i-l+1</p>

<pre><code class="language-cpp">class Solution {
public:
    int longestValidParentheses(string&amp; s) {
        stack&lt;int&gt; t; vector&lt;int&gt; f(s.length(), 0); int result = 0;
        for (int i=0; i&lt;s.length(); ++i) {
            if (s[i] == '(') t.push(i);
            else if (!t.empty()) {
                int l = t.top(); t.pop();
                f[i] = i - l + 1 + (l&gt;0 ? f[l-1] : 0);
                result = max(result, f[i]);
            }
        }
        return result;
    }
};
</code></pre>

<h2 id="33-search-in-rotated-sorted-array">33. Search in Rotated Sorted Array</h2>

<p>链接：<a href="https://leetcode.com/problems/search-in-rotated-sorted-array/#/description">https://leetcode.com/problems/search-in-rotated-sorted-array/#/description</a></p>

<pre><code class="language-cpp">class Solution {
public:
    int search(vector&lt;int&gt;&amp; nums, int target) {
        int l = 0, h = nums.size();
        while (l &lt; h) {
            int m = (l + h) / 2;
            if (nums[m] &lt; target) {
                if (nums[m] &gt;= nums[0]) l = m + 1; 
                else { if (target &gt;= nums[0]) h = m; else l = m + 1; }
            } else if (nums[m] &gt; target) {
                if (nums[m] &gt;= nums[0]) { if (target &gt;= nums[0]) h = m; else l = m + 1; }
                else h = m;
            } else {
                return m;
            }
        }
        return -1;
    }
};
</code></pre>

<pre><code>class Solution {
public:
    int search(vector&lt;int&gt;&amp; nums, int target) {
        int l = 0, h = nums.size();
        while (l &lt; h) {
            int m = (l + h) / 2;
            if (nums[m] &lt; target) {
                if (nums[m] &lt;  nums[0] &amp;&amp; target &gt;= nums[0]) h = m;     else l = m + 1;
            } else if (nums[m] &gt; target) {
                if (nums[m] &gt;= nums[0] &amp;&amp; target &lt;  nums[0]) l = m + 1; else h = m;
            } else {
                return m;
            }
        }
        return -1;
    }
};
</code></pre>

<h2 id="34-search-for-a-range">34. Search for a Range</h2>

<p>链接： <a href="https://leetcode.com/problems/search-for-a-range/#/description">https://leetcode.com/problems/search-for-a-range/#/description</a></p>

<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) {
        int s = findStartPosition(nums, target);
        if (s == -1) return {-1, -1};
        int e = findEndPosition(nums, target);
        return vector&lt;int&gt;({s, e});
    }
    
    int findStartPosition(vector&lt;int&gt;&amp; nums, int target) {
        int l = 0, h = nums.size(), m, result = -1;
        while (l &lt; h) {
            m = (l + h) / 2;
            if      (nums[m] &lt; target)  { l = m + 1; }
            else if (nums[m] &gt; target)  { h = m; }
            else                        { h = m; result = m; }
        }
        return result;
    }
    
    int findEndPosition(vector&lt;int&gt; &amp;nums, int target) {
        int l = 0, h = nums.size(), m, result = -1;
        while (l &lt; h) {
            m = (l + h) / 2;
            if      (nums[m] &lt; target)  { l = m + 1; }
            else if (nums[m] &gt; target)  { h = m; }
            else                        { l = m + 1; result = m; }
        }
        return result;
    }
};
</code></pre>

<h2 id="35-search-insert-position">35. Search Insert Position</h2>

<p>链接：<a href="https://leetcode.com/problems/search-insert-position/#/description">https://leetcode.com/problems/search-insert-position/#/description</a></p>

<pre><code class="language-cpp">class Solution {
public:
    int searchInsert(vector&lt;int&gt;&amp; nums, int target) {
        int l = 0, h = nums.size(), m;
        while (l &lt; h) {
            m = (l + h) / 2;
            if (nums[m] &lt; target) {
                l = m + 1;
            } else if (nums[m] &gt; target) {
                h = m;
            } else {
                break;
            }
        }
        return (l + h) / 2;
    }
};
</code></pre>

<h2 id="36-valid-sudoku">36 Valid Sudoku</h2>

<p>题目： <a href="https://leetcode.com/problems/valid-sudoku/description/">https://leetcode.com/problems/valid-sudoku/description/</a>
思路：分别按行、列、3x3遍历，看是否满足无重复的数字即可，9 ms。</p>

<pre><code class="language-cpp">class Solution {
public:
    bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {
        for (int row = 0; row &lt; 9; row++) 
            if (! isValidRowOfSudoku(board, row)) return false;
        for (int col = 0; col &lt; 9; col++) 
            if (! isValidColOfSudoku(board, col)) return false;
        for (int row = 0; row &lt; 9; row += 3) for (int col = 0; col &lt; 9; col += 3) 
            if (! isVaild3x3OfSudoku(board, row, col)) return false;
        return true;
    }
    
    bool isValidRowOfSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board, int row) {
        char tbl[9]; fill_n(tbl, 9, 1);
        for (int col = 0; col &lt; 9; col++) {
            char ch = board[row][col];
            if      (ch == '.')   continue;
            else if (tbl[ch-'1']) tbl[ch-'1'] = 0;
            else                  return false;
        }
        return true;
    }
 
    bool isValidColOfSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board, int col) {
        char tbl[9]; fill_n(tbl, 9, 1);
        for (int row = 0; row &lt; 9; row++) {
            char ch = board[row][col];
            if      (ch == '.')   continue;
            else if (tbl[ch-'1']) tbl[ch-'1'] = 0;
            else                  return false;
        }
        return true;
    }
    
    bool isVaild3x3OfSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board, int row, int col) {
        char tbl[9]; fill_n(tbl, 9, 1);
        for (int i = 0; i &lt; 3; i++) for (int j = 0; j &lt; 3; j++) {
            char ch = board[row+i][col+j];
            if      (ch == '.')   continue;
            else if (tbl[ch-'1']) tbl[ch-'1'] = 0;
            else                  return false;
        }
        return true;
    }
};
</code></pre>

<p>思路2：根据上面的答案，将三个for循环缩小为一个，19ms，目前看来循环分开效率要高一些。</p>

<pre><code class="language-cpp">class Solution {
public:
    bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {
        for (int i = 0; i &lt; 9; i++) {
            char row[9] = {0}, col[9] = {0}, blk[9] = {0};
            for (int j = 0; j &lt; 9; j++) {
                char ch;
                ch = board[i][j];
                if (ch != '.') if (!row[ch-'1']) row[ch-'1'] = 1; else return false;
                ch = board[j][i];
                if (ch != '.') if (!col[ch-'1']) col[ch-'1'] = 1; else return false;
                ch = board[i/3*3+j/3][i%3*3+j%3];
                if (ch != '.') if (!blk[ch-'1']) blk[ch-'1'] = 1; else return false;
            }
        }
        return true;
    }
};
</code></pre>

<h2 id="37-sodoku-solver">37. Sodoku Solver</h2>

<p>链接：<a href="https://leetcode.com/problems/sudoku-solver/description/">https://leetcode.com/problems/sudoku-solver/description/</a>
思路：广搜，按位置遍历，搜索&rsquo;.&lsquo;所有可能值，然后递归搜索下去，看看是否能够得出可能解，9ms。</p>

<pre><code class="language-cpp">class Solution {
public:
    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {
        BFS(board, 0, 0);
    }
    
    bool BFS(vector&lt;vector&lt;char&gt;&gt;&amp; board, int i, int j) {
        if (i == 9)   return true;
        if (board[i][j] != '.') return BFS(board, i=i+(j+1)/9, (j+1)%9);
        
        char tbl[9] = {0}, ch;
        for (int k = 0; k &lt; 9; k++) {
            ch = board[i][k]; if (ch != '.') tbl[ch-'1'] = 1;
            ch = board[k][j]; if (ch != '.') tbl[ch-'1'] = 1;
            ch = board[i/3*3+k/3][j/3*3+k%3];
            if (ch != '.') tbl[ch-'1'] = 1;
        }

        for (int k = 0; k &lt; 9; k++) {
            if (tbl[k] == 1) continue;
            board[i][j] = '1' + k;
            if (BFS(board, i, j)) return true;
        }
        board[i][j] = '.';
        return false;
    }
};
</code></pre>

<h2 id="38-count-and-say">38. Count and Say</h2>

<p>链接：<a href="https://leetcode.com/problems/count-and-say/description/">https://leetcode.com/problems/count-and-say/description/</a>
思路：打表记录当前到n的所有可能，时间换空间。转换的时候需要考虑细节情况。</p>

<pre><code class="language-cpp">class Solution {
public:
    string countAndSay(int n) {
        static vector&lt;string&gt; tbl = {&quot;1&quot;, &quot;11&quot;, &quot;21&quot;, &quot;1211&quot;, &quot;111221&quot;};
        for (int i = tbl.size(); i &lt; n; i++) {
            tbl.push_back(next(tbl.back()));
        }
        return tbl[n-1];
    }
    
    string next(string&amp; curr) {
        int cnt = 1; char ch = curr[0]; string next;
        for (int i = 1; i &lt;= curr.length(); i++) {
            if (i &lt; curr.length() &amp;&amp; curr[i] == curr[i-1]) { 
                cnt++; 
            } else if (i &lt; curr.length()) {
                next.append(to_string(cnt)).push_back(ch); 
                cnt = 1; ch = curr[i];
            } else { 
                next.append(to_string(cnt)).push_back(ch);  
            }
        }
        return move(next);
    }
};
</code></pre>

<h2 id="39-combination-sum">39. Combination Sum</h2>

<p>链接：<a href="https://leetcode.com/problems/combination-sum">https://leetcode.com/problems/combination-sum</a>
思路：广度搜索，$f(n, [a,b,c]) = f(n-a, [a,b,c]) + f(n-b, [b,c]) + f(n-c, [c])$。注意去重，所有包含a的答案，已经在$f[n-a, [a,b,c]]$中包含了，所以$f(n-b,[b-c])$从b开始。</p>

<pre><code class="language-cpp">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) {
        vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path;
        sort(begin(candidates), end(candidates));
        DFS(candidates, 0, target, path, result);
        return move(result);
    }
    
    void DFS(const vector&lt;int&gt;&amp; candidates, int lo, int target, vector&lt;int&gt;&amp; path, vector&lt;vector&lt;int&gt;&gt;&amp; result) {
        if (target == 0) { result.push_back(path); return; }
        for (int i = lo; i &lt; candidates.size(); i++) {
            int candidate = candidates[i];
            if (target &lt; candidate) return;
            path.push_back(candidate);
            DFS(candidates, i, target - candidate, path, result);
            path.pop_back();
        }
    }
};
</code></pre>

<h2 id="40-combination-sum-ii">40. Combination Sum II</h2>

<p>链接：<a href="https://leetcode.com/problems/combination-sum-ii/description/">https://leetcode.com/problems/combination-sum-ii/description/</a>
思路：先排序，后深搜，注意去重。关键是在path选取第n个数字时，保证唯一。</p>

<pre><code class="language-cpp">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) {
        vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path;
        sort(begin(candidates), end(candidates));
        DFS(candidates, target, 0, path, result);
        return result;
    }
    
    void DFS(vector&lt;int&gt;&amp; nums, int target, int curr, vector&lt;int&gt; &amp;path, vector&lt;vector&lt;int&gt;&gt; &amp;result) {
        if (target &lt;  0) return;
        if (target == 0) { result.push_back(path); return; }
        for (int i=curr; i&lt;nums.size(); i++) {
            if (i&gt;curr &amp;&amp; nums[i]==nums[i-1]) continue;
            path.push_back(nums[i]);
            DFS(nums, target-nums[i], i+1, path, result);
            path.pop_back();
        }
    }
};
</code></pre>
    </div>

    
    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">amendgit</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">2018-07-01</span>
  </p>
  
  
</div>

    
    

    <footer class="post-footer">
      <div class="post-tags">
          
          <a href="/tags/leetcode/">leetcode</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/leetcode/leetcode-solutions-041-060/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Leetcode Solutions 041 060</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/leetcode/leetcode-solutions-001-020/">
            <span class="next-text nav-default">Leetcode Solutions 001-020</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:shijian0912@163.com" class="iconfont icon-email" title="email"></a>
      <a href="http://localhost:1313" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
      <a href="http://localhost:1313" class="iconfont icon-twitter" title="twitter"></a>
      <a href="http://localhost:1313" class="iconfont icon-facebook" title="facebook"></a>
      <a href="http://localhost:1313" class="iconfont icon-linkedin" title="linkedin"></a>
      <a href="http://localhost:1313" class="iconfont icon-google" title="google"></a>
      <a href="http://localhost:1313" class="iconfont icon-github" title="github"></a>
      <a href="http://localhost:1313" class="iconfont icon-weibo" title="weibo"></a>
      <a href="http://localhost:1313" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="http://localhost:1313" class="iconfont icon-douban" title="douban"></a>
      <a href="http://localhost:1313" class="iconfont icon-pocket" title="pocket"></a>
      <a href="http://localhost:1313" class="iconfont icon-tumblr" title="tumblr"></a>
      <a href="http://localhost:1313" class="iconfont icon-instagram" title="instagram"></a>
  <a href="http://localhost:1313/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    
      2017 - 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">amendgit</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>








</body>
</html>
