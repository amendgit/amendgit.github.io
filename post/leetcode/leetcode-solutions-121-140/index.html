<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Leetcode Solutions 121 140 - amendgit`s blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="amendgit" />
  <meta name="description" content="本文用来记录我的leetcode解题报告，用于之后的代码优化、查阅和复习。这里是第121题到第140题。部分答案是以前的答案。
" />

  <meta name="keywords" content="amendgit, blog" />






<meta name="generator" content="Hugo 0.52" />


<link rel="canonical" href="http://localhost:1313/post/leetcode/leetcode-solutions-121-140/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">







<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="Leetcode Solutions 121 140" />
<meta property="og:description" content="本文用来记录我的leetcode解题报告，用于之后的代码优化、查阅和复习。这里是第121题到第140题。部分答案是以前的答案。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/post/leetcode/leetcode-solutions-121-140/" /><meta property="article:published_time" content="2018-09-18T08:31:24&#43;08:00"/>
<meta property="article:modified_time" content="2018-09-18T08:31:24&#43;08:00"/>

<meta itemprop="name" content="Leetcode Solutions 121 140">
<meta itemprop="description" content="本文用来记录我的leetcode解题报告，用于之后的代码优化、查阅和复习。这里是第121题到第140题。部分答案是以前的答案。">


<meta itemprop="datePublished" content="2018-09-18T08:31:24&#43;08:00" />
<meta itemprop="dateModified" content="2018-09-18T08:31:24&#43;08:00" />
<meta itemprop="wordCount" content="3629">



<meta itemprop="keywords" content="leetcode," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Leetcode Solutions 121 140"/>
<meta name="twitter:description" content="本文用来记录我的leetcode解题报告，用于之后的代码优化、查阅和复习。这里是第121题到第140题。部分答案是以前的答案。"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">amendgit&#39;s blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">amendgit&#39;s blog</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Leetcode Solutions 121 140</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-09-18 </span>
        
        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#121-best-time-to-buy-and-sell-stock">121. Best Time to Buy and Sell Stock</a></li>
<li><a href="#122-best-time-to-buy-and-sell-stock-ii">122. Best Time to Buy and Sell Stock II</a></li>
<li><a href="#123-best-time-to-buy-and-sell-stock-iii">123. Best Time to Buy and Sell Stock III</a></li>
<li><a href="#124-binary-tree-maximum-path-sum">124. Binary Tree Maximum Path Sum</a></li>
<li><a href="#125-valid-palindrome">125. Valid Palindrome</a></li>
<li><a href="#126-word-ladder-ii">126. Word Ladder II</a></li>
<li><a href="#127-word-ladder">127. Word Ladder</a></li>
<li><a href="#128-longest-consecutive-sequence">128. Longest Consecutive Sequence</a></li>
<li><a href="#129-sum-root-to-leaf-numbers">129. Sum Root to Leaf Numbers</a></li>
<li><a href="#130-surrounded-regions">130. Surrounded Regions</a></li>
<li><a href="#131-palindrome-partitioning">131. Palindrome Partitioning</a></li>
<li><a href="#132-palindrome-partitioning-ii">132. Palindrome Partitioning II</a></li>
<li><a href="#133-clone-graph">133. Clone Graph</a></li>
<li><a href="#134-gas-station">134. Gas Station</a></li>
<li><a href="#135">135.</a></li>
<li><a href="#136-single-number">136. Single Number</a></li>
<li><a href="#137-single-number-ii">137. Single Number II</a></li>
<li><a href="#138-copy-list-with-random-pointer">138. Copy List with Random Pointer</a></li>
<li><a href="#139-word-break">139. Word Break</a></li>
<li><a href="#140-word-break-ii">140. Word Break II</a></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    

    
    <div class="post-content">
      <p>本文用来记录我的leetcode解题报告，用于之后的代码优化、查阅和复习。这里是第121题到第140题。部分答案是以前的答案。</p>

<h2 id="121-best-time-to-buy-and-sell-stock">121. Best Time to Buy and Sell Stock</h2>

<p>链接：<a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/">https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/</a></p>

<pre><code class="language-cpp">class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        if (prices.empty()) return 0;
        int buy = prices[0], profit = 0;
        for (int i=1; i&lt;prices.size(); i++) {
            if (prices[i] &gt; buy) profit = max(prices[i]-buy, profit);
            else                 buy    = prices[i];
        }
        return profit;
    }
};
</code></pre>

<p>4年前的答案</p>

<pre><code class="language-cpp">class Solution {
public:
    int maxProfit(vector&lt;int&gt; &amp;prices) {
        if (prices.empty()) {
            return 0;
        }
        
        int min_price = prices[0], max_price = 0;
        int max_profit = 0;
        
        for (int i=0; i&lt;prices.size(); i++) {
            if (prices[i] &lt; min_price) {
                min_price = prices[i];
                max_price = min_price;
            }
            
            if (max_profit == 0) {
                if (i+1 &lt; prices.size() &amp;&amp; prices[i] &lt; prices[i+1]) {
                    max_price = prices[i+1];
                    max_profit = prices[i+1] - prices[i];
                }
            }
            
            if (prices[i] &gt; max_price) {
                max_price = prices[i];
                int new_profit = max_price - min_price;
                if (new_profit &gt; max_profit) {
                    max_profit = new_profit;
                }
            }
        }
        
        return max_profit;
    }
};
</code></pre>

<h2 id="122-best-time-to-buy-and-sell-stock-ii">122. Best Time to Buy and Sell Stock II</h2>

<p>链接：<a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/</a></p>

<p>因为可以多个transaction，所以赚钱就卖就可以，贪心。</p>

<pre><code class="language-cpp">class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        if (prices.empty()) return 0;
        int buy = prices[0], profit = 0;
        for (int i=0; i&lt;prices.size(); i++) {
            if (buy &lt; prices[i]) profit += prices[i] - buy;
            buy = prices[i];
        }
        return profit;
    }
};
</code></pre>

<pre><code class="language-cpp">class Solution {
public:
    int maxProfit(vector&lt;int&gt; &amp;prices) {
        int len = prices.size();
        int i = 2;
        if (i &gt; len) {
            return 0;
        } 
        
        int hold = 0, cur = 0, pre = 0;
        int max_profit = 0;
        
        pre = prices[0];
        cur = prices[1];
        hold = pre;
        
        while (true) {
             while (pre &gt;= cur) {
                if (i &gt;= len) {
                    return max_profit;
                }
                pre = cur;
                cur = prices[i];
                i = i + 1;
                hold = pre;
             }
            
            while (pre &lt;= cur) {
                if (i &gt;= len) {
                    max_profit = max_profit + cur - hold;
                    return max_profit;
                }
                pre = cur;
                cur = prices[i];
                i = i + 1;
            }
            
            max_profit = max_profit + pre - hold;
        }
        
        return max_profit;
    }
};
</code></pre>

<h2 id="123-best-time-to-buy-and-sell-stock-iii">123. Best Time to Buy and Sell Stock III</h2>

<p>link: <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/description/">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/description/</a></p>

<p>ltor[i]表示prices[0, i)的最大profit，rtol[i]表示prices[i, n)的最大profit。然后计算两者之和即可。时间O(n)，空间O(n)。</p>

<pre><code class="language-cpp">class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        int len = prices.size(), profit = 0;
        if (len == 0) return profit;
        vector&lt;int&gt; ltor(len+1, 0), rtol(len+1, 0);
        profit = 0;
        for (int i=1, buy=prices[0]; i&lt;len; i++) {
            if (buy &lt; prices[i]) profit = max(prices[i] - buy, profit);
            else                 buy = prices[i];
            ltor[i+1] = profit;
        }
        profit = 0;
        for (int i=len-2, sell=prices[len-1]; i&gt;=0; i--) {
            if (sell &gt; prices[i]) profit = max(sell - prices[i], profit);
            else                  sell = prices[i];
            rtol[i] = profit;
        }
        int result = 0;
        for (int i=0; i&lt;len; i++) result = max(result, ltor[i] + rtol[i]);
        return result;
    }
};
</code></pre>

<p>discuss里的思路，初始为0，a表示[0, i) buy一股最多剩余的钱数，b表示[0, i) buy sell一股最多剩余的钱数，c表示[0, i) buy sell buy一股最多剩余的钱数，d表示[0, i) buy sell buy sell剩余最多的钱数。</p>

<pre><code class="language-cpp">class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        int len = prices.size(), a=INT_MIN, b=0, c=INT_MIN, d=0;
        for (int i=0; i&lt;len; i++) {
            d = max(d, c+prices[i]);
            c = max(c, b-prices[i]);
            b = max(b, a+prices[i]);
            a = max(a, 0-prices[i]);
        }
        return d;
    }
};
</code></pre>

<h2 id="124-binary-tree-maximum-path-sum">124. Binary Tree Maximum Path Sum</h2>

<p>链接：<a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/description/">https://leetcode.com/problems/binary-tree-maximum-path-sum/description/</a></p>

<p>分别计算左右子树的最大值和最大尾值，注意需要llast和rlast大于0才会更新last值，小于等于0的值，对于last值没有贡献。</p>

<pre><code class="language-cpp">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int maxPathSum(TreeNode* root) {
        if (!root) return 0;
        int maxsum = 0, last = 0; 
        maxPathSum(root, maxsum, last);
        return maxsum;
    }

    void maxPathSum(TreeNode *node, int&amp; maxsum, int&amp; last) {
        if (!node) return;
        int nval = node-&gt;val;
        int lmax = INT_MIN, llast = 0;
        maxPathSum(node-&gt;left , lmax, llast);
        int rmax = INT_MIN, rlast = 0;
        maxPathSum(node-&gt;right, rmax, rlast);
        last = node-&gt;val; 
        if (llast &gt; 0) last = max(llast+nval, last);
        if (rlast &gt; 0) last = max(rlast+nval, last);
        maxsum = max({lmax, rmax, last, llast+nval+rlast}); 
    }
};
</code></pre>

<pre><code class="language-cpp">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int maxPathSum(TreeNode* root) {
        int maxsum = INT_MIN;
        DFS(root, maxsum);
        return maxsum;
    }
    
    int DFS(TreeNode *root, int&amp; maxsum) {
        if (!root) return 0;
        int sum = root-&gt;val;
        int l = DFS(root-&gt;left, maxsum);
        int r = DFS(root-&gt;right, maxsum);
        if (l&gt;0) sum += l;
        if (r&gt;0) sum += r;
        maxsum = max(sum, maxsum);
        return max(l, r) &gt; 0 ? max(l,r)+root-&gt;val : root-&gt;val;
    }
};
</code></pre>

<h2 id="125-valid-palindrome">125. Valid Palindrome</h2>

<p>link: <a href="https://leetcode.com/problems/valid-palindrome/description/">https://leetcode.com/problems/valid-palindrome/description/</a></p>

<p>emmm, 提交错误次数有点多。最后看答案，才知道题目理解错了，<code>...,,,</code>这种不包含字符的，返回true。</p>

<pre><code class="language-cpp">class Solution {
public:
    bool isPalindrome(string s) {
        int i = 0, j = s.length()-1;
        while (i &lt; j) {
            while (i&lt;j &amp;&amp; !isalnum(s[i])) i++;
            while (i&lt;j &amp;&amp; !isalnum(s[j])) j--;
            if (tolower(s[i++]) != tolower(s[j--])) return false;
        }
        return true;
    }
};
</code></pre>

<h2 id="126-word-ladder-ii">126. Word Ladder II</h2>

<p>链接：<a href="https://leetcode.com/problems/word-ladder-ii/description/">https://leetcode.com/problems/word-ladder-ii/description/</a></p>

<pre><code class="language-cpp">class Solution {
public:
    vector&lt;vector&lt;string&gt;&gt; findLadders(string &amp;start, string &amp;end, unordered_set&lt;string&gt; &amp;dict) {
        unordered_map&lt;string, vector&lt;string&gt;&gt; parent;
        unordered_set&lt;string&gt; curr, next, visited;
        int len = start.length(); 
        bool found = false;
        
        curr.insert(start); visited.insert(start);
        
        while (!curr.empty()) {
            for (auto&amp; word : curr) {
                string w = word;
                for (int i=0; i&lt;len; i++) for (char ch='a'; ch&lt;='z'; ch++) {
                    if (ch == w[i]) continue;
                    swap(w[i], ch);
                    if (dict.find(w)!=dict.end() &amp;&amp; visited.find(w)==visited.end()) {
                        next.insert(w);
                        parent[w].push_back(word);
                        if (w == end) found = true;
                    }
                    swap(w[i], ch);
                }
            }
            if (found) break;
            for (auto&amp; word : next) visited.insert(word);
            curr.clear(); swap(curr, next);
        }
        
        vector&lt;vector&lt;string&gt;&gt; result; vector&lt;string&gt; path;
        genPath(start, end, parent, path, result);
        return result;
    }
    
    void genPath(string&amp; target, string&amp; word, unordered_map&lt;string, vector&lt;string&gt;&gt; &amp;parent, 
                 vector&lt;string&gt; &amp;path, vector&lt;vector&lt;string&gt;&gt; &amp;result) {
        path.push_back(word);
        if (word == target) {
            result.push_back(path);
            reverse(result.back().begin(), result.back().end());
        }
        for (auto&amp; w : parent[word]) genPath(target, w, parent, path, result);
        path.pop_back();
    }
};
</code></pre>

<h2 id="127-word-ladder">127. Word Ladder</h2>

<p>链接：<a href="https://leetcode.com/problems/word-ladder/description/">https://leetcode.com/problems/word-ladder/description/</a></p>

<pre><code class="language-cpp">class Solution {
public:
    int ladderLength(string&amp; start, string&amp; end, unordered_set&lt;string&gt;&amp; words) {
        unordered_set&lt;string&gt; visited, curr, next;
        visited.insert(start), curr.insert(start);
        int depth = 1;
        while (!curr.empty()) {
            depth++;
            for (auto word : curr) {
                for (int i=0; i&lt;word.size(); i++) for (char c='a'; c&lt;='z'; c++) {
                    if (word[i] == c) continue;
                    swap(word[i], c);
                    if (word == end) return depth;
                    if (words.find(word)!=words.end() &amp;&amp; visited.find(word)==visited.end()) next.insert(word);
                    swap(word[i], c);
                }
            }
            for (auto&amp; word : next) visited.insert(word);
            curr.clear(); swap(curr, next);
        }
        return 0;
    }
};
</code></pre>

<h2 id="128-longest-consecutive-sequence">128. Longest Consecutive Sequence</h2>

<p>link: <a href="https://leetcode.com/problems/longest-consecutive-sequence/description/">https://leetcode.com/problems/longest-consecutive-sequence/description/</a></p>

<p>思路：下一个连续数字一定出现在边界，每次当前连续区间的边界的数值。上界下界和当前，当前是为了防止上界下界至少有一个不存在的情况，这样当前就是边界了。注意map的insert和operator[]的区别。</p>

<pre><code class="language-cpp">class Solution {
public:
    int longestConsecutive(vector&lt;int&gt;&amp; nums) {
        unordered_map&lt;int, int&gt; tbl; int result = 0;
        for (int n : nums) {
            int up = 0, lo = 0; auto it = end(tbl);
            if (tbl.find(n  ) != end(tbl)) continue;
            if ((it = tbl.find(n+1)) != end(tbl)) up = it-&gt;second;
            if ((it = tbl.find(n-1)) != end(tbl)) lo = it-&gt;second;
            int sum = lo + up + 1;
            result = max(sum, result);
            // tbl.insert({{n+up, sum}, {n, sum}, {n-lo, sum}}); // Wrong Answer.
            tbl[n+up] = tbl[n] = tbl[n-lo] = sum;
        }
        return result;
    }
};
</code></pre>

<h2 id="129-sum-root-to-leaf-numbers">129. Sum Root to Leaf Numbers</h2>

<p>链接：<a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/description/">https://leetcode.com/problems/sum-root-to-leaf-numbers/description/</a></p>

<pre><code class="language-cpp">/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    void sumNumbers(TreeNode *node, int num, int&amp; sum) {
        num = num * 10 + node-&gt;val ;
        if (!node-&gt;left &amp;&amp; !node-&gt;right) { sum += num; return; }
        if (node-&gt;left ) sumNumbers(node-&gt;left , num, sum);
        if (node-&gt;right) sumNumbers(node-&gt;right, num, sum);
    }
    
    int sumNumbers(TreeNode *root) {
        int sum = 0;
        if (root) sumNumbers(root, 0, sum);
        return sum;
    }
};
</code></pre>

<h2 id="130-surrounded-regions">130. Surrounded Regions</h2>

<p>link: <a href="https://leetcode.com/problems/surrounded-regions/description/">https://leetcode.com/problems/surrounded-regions/description/</a></p>

<pre><code class="language-cpp">class Solution {
public:
    void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) {
        if (board.size() &lt;= 0) return ;
        int h = board.size(); int w = board[0].size();
        for (int i=0; i&lt;w; i++) { BFS(board, 0, i); BFS(board, h-1, i  ); }
        for (int i=0; i&lt;h; i++) { BFS(board, i, 0); BFS(board, i  , w-1); }
        for (int i=0; i&lt;h; i++) for (int j=0; j&lt;w; j++) {
            if      (board[i][j] == 'O') board[i][j] = 'X';
            else if (board[i][j] == '.') board[i][j] = 'O';
        }
    }
    
    void BFS(vector&lt;vector&lt;char&gt;&gt; &amp;board, int i, int j) {
        queue&lt;pair&lt;int, int&gt;&gt; q;
        q.push({i, j});
        while (!q.empty()) {
            auto cur = q.front(); q.pop();
            int i = cur.first, j = cur.second;
            if (board[i][j] == 'O') board[i][j] = '.'; else continue ;
            if (i &gt;= 1)                q.push({i-1, j  });
            if (j &gt;= 1)                q.push({i  , j-1});
            if (i+1 &lt; board.size())    q.push({i+1, j  });
            if (j+1 &lt; board[0].size()) q.push({i  , j+1});
        }
    }
};
</code></pre>

<h2 id="131-palindrome-partitioning">131. Palindrome Partitioning</h2>

<p>link: <a href="https://leetcode.com/problems/palindrome-partitioning/description/">https://leetcode.com/problems/palindrome-partitioning/description/</a></p>

<p>先dp算出所有的回文子串，然后再深搜即可。</p>

<pre><code class="language-cpp">class Solution {
public:
    vector&lt;vector&lt;string&gt;&gt; partition(string&amp; s) {
        const int N = s.length();
        vector&lt;vector&lt;int&gt;&gt; f(N, vector&lt;int&gt;(N, 0));
        for (int j=0; j&lt;N; j++) for (int i=0; i&lt;=j; i++) {
            f[i][j] = s[i] == s[j] &amp;&amp; ((j-i&lt;=2) || f[i+1][j-1]);
        }
        vector&lt;vector&lt;string&gt;&gt; result; vector&lt;string&gt; path;
        partition(s, f, 0, path, result);
        return move(result);
    }

    void partition(string&amp; s, vector&lt;vector&lt;int&gt;&gt;&amp; f, int i, vector&lt;string&gt;&amp; path, vector&lt;vector&lt;string&gt;&gt;&amp; result) {
        if (i == s.length()) { result.push_back(path); return; } 
        for (int j=i; j&lt;s.length(); j++) {
            if (!f[i][j]) continue;
            path.push_back(s.substr(i, j-i+1));
            partition(s, f, j+1, path, result);
            path.pop_back();
        }
    }
};
</code></pre>

<h2 id="132-palindrome-partitioning-ii">132. Palindrome Partitioning II</h2>

<p>link: <a href="https://leetcode.com/problems/palindrome-partitioning-ii/description/">https://leetcode.com/problems/palindrome-partitioning-ii/description/</a></p>

<p>两次dp，第一次计算回文子串，每次计算出来一个回文子串，就更新mincut[h]。</p>

<pre><code class="language-cpp">class Solution {
public:
    int minCut(string&amp; s) {
        const int len = s.length(); int cut[len]; vector&lt;vector&lt;int&gt;&gt; f(len, vector&lt;int&gt;(len, 0));
        for (int i=0; i&lt;len; i++) cut[i] = i;
        for (int h=0; h&lt;len; h++) for (int l=0; l&lt;=h; l++) {
            f[l][h] = s[l]==s[h] &amp;&amp; (h-l&lt;2 || f[l+1][h-1]);
            if (f[l][h]) cut[h] = l==0 ? 0 : min(cut[h], cut[l-1]+1);
        }
        return cut[len-1];
    }
};
</code></pre>

<h2 id="133-clone-graph">133. Clone Graph</h2>

<p>link: <a href="https://leetcode.com/problems/clone-graph/description/">https://leetcode.com/problems/clone-graph/description/</a></p>

<p>深搜，然后用一个map记录已经克隆过的节点，并做一个映射。</p>

<pre><code class="language-cpp">/**
 * Definition for undirected graph.
 * struct UndirectedGraphNode {
 *     int label;
 *     vector&lt;UndirectedGraphNode *&gt; neighbors;
 *     UndirectedGraphNode(int x) : label(x) {};
 * };
 */
typedef unordered_map&lt;UndirectedGraphNode*, UndirectedGraphNode*&gt; UndirectedGraphNodeMap;

class Solution {
public:
    UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {
        if (!node) return NULL;
        UndirectedGraphNodeMap tbl;
        return cloneGraph(node, tbl);
    }
    
    UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node, UndirectedGraphNodeMap&amp; tbl) {
        auto it = tbl.find(node);
        if (it != end(tbl)) return it-&gt;second;
        UndirectedGraphNode *clone = new UndirectedGraphNode(node-&gt;label);
        tbl[node] = clone;
        for (auto neighbor : node-&gt;neighbors) 
            clone-&gt;neighbors.push_back(cloneGraph(neighbor, tbl));
        return clone;
    }
};
</code></pre>

<h2 id="134-gas-station">134. Gas Station</h2>

<p>link: <a href="https://leetcode.com/problems/gas-station/description/">https://leetcode.com/problems/gas-station/description/</a></p>

<p>遍历，考察细节的，边界要注意要，尤其是<code>j&lt;=N</code>和 <code>if (j&gt;N) return i;</code></p>

<pre><code class="language-cpp">class Solution {
public:
    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) {
        int N = gas.size();
        for (int i=0, j, tank; i&lt;N; i++) {
            for (j=0, tank=0; j&lt;=N; j++) {
                int curr = (j+i) % N;
                tank += gas[curr]; tank -= cost[curr];
                if (tank &lt; 0) break;
            }
            if (j &gt; N) return i;
        }
        return -1;
    }
};
</code></pre>

<h2 id="135">135.</h2>

<p>link: <a href="https://leetcode.com/problems/candy/description/">https://leetcode.com/problems/candy/description/</a></p>

<p>1384ms，感觉用深搜即慢又复杂，emmm。。。还是看看别人的思路吧。不过居然被我硬搜出来了，不容易啊。</p>

<pre><code class="language-cpp">class Solution {
public:
    int candy(vector&lt;int&gt;&amp; R) {
        int _ = 0, sum = 0;
        candy(R, 0, R.size(), _, _, sum);
        return sum;
    }

    void candy(vector&lt;int&gt;&amp; R, int lo, int hi, int&amp; l, int&amp; r, int&amp; sum) {
        if (hi-lo == 0) { l = 0; r = 0; sum = 0; return; }
        if (hi-lo == 1) { l = 1; r = 1; sum = 1; return; }
        int mi=lo; for (int i=lo; i&lt;hi; i++) if (R[i] &gt; R[mi]) mi = i;
        int lsum=0, rsum=0, num=1, ll, lr, rl, rr;
        candy(R, lo  , mi, ll, lr, lsum);
        candy(R, mi+1, hi, rl, rr, rsum);
        if (mi-1&gt;=lo &amp;&amp; R[mi]&gt;R[mi-1]) num = max(num, lr + 1);
        if (mi+1&lt; hi &amp;&amp; R[mi]&gt;R[mi+1]) num = max(num, rl + 1);
        l = ll, r = rr;
        if (mi == lo  ) l = num;
        if (mi == hi-1) r = num;
        sum = lsum + num + rsum;
    }
};
</code></pre>

<p>现在ltor遍历一遍，保证左边ok，在rtol遍历一遍，保证右边ok，emmm&hellip;，fair simple.</p>

<pre><code class="language-cpp">class Solution {
public:
    int candy(vector&lt;int&gt;&amp; R) {
        int N = R.size(); vector&lt;int&gt; nums(N, 1);
        for (int i=1; i&lt;N; i++) 
            if (R[i] &gt; R[i-1]) nums[i] = nums[i-1] + 1;
        for (int i=N-2; i&gt;=0; i--) 
            if (R[i] &gt; R[i+1]) nums[i] = max(nums[i+1]+1, nums[i]);
        int sum = 0; for (auto n : nums) sum += n;
        return sum;
    }
};
</code></pre>

<h2 id="136-single-number">136. Single Number</h2>

<p>link: <a href="https://leetcode.com/problems/single-number/description/">https://leetcode.com/problems/single-number/description/</a></p>

<pre><code class="language-cpp">#include &lt;map&gt;

using namespace std;

typedef map&lt;int, int&gt; iimap;
typedef map&lt;int, int&gt;::iterator ITER;

class Solution {
public:
    int singleNumber(int A[], int n) {
        // IMPORTANT: Please reset any member data you declared, as
        // the same Solution instance will be reused for each test case.
       int x = 0;
       for (int i=0; i&lt;n; i++) {
           x ^= A[i];
       }
       return x;
    }
};
</code></pre>

<h2 id="137-single-number-ii">137. Single Number II</h2>

<p>link: <a href="https://leetcode.com/problems/single-number-ii/description/">https://leetcode.com/problems/single-number-ii/description/</a></p>

<pre><code class="language-cpp">class Solution {
public:
    int singleNumber(int A[], int n) {
        int ones = 0, twos = 0, threes = 0;
        
        for (int i=0; i&lt;n; i++) {
            twos = twos | (ones &amp; A[i]);
            ones = ones ^ A[i];
            threes = ones &amp; twos;
            
            ones = ones &amp; (~threes);
            twos = twos &amp; (~threes);
        }
        
        return ones;
    }
};
</code></pre>

<h2 id="138-copy-list-with-random-pointer">138. Copy List with Random Pointer</h2>

<p>link: <a href="https://leetcode.com/problems/copy-list-with-random-pointer/description/">https://leetcode.com/problems/copy-list-with-random-pointer/description/</a></p>

<p>跟cloneGraph那题有点类似。还有个思路是穿插节点 A -&gt; B -&gt; A -&gt; B -&gt; &hellip;这种的，然后将random指针设置正确，在分割链表。</p>

<pre><code class="language-cpp">/**
 * Definition for singly-linked list with a random pointer.
 * struct RandomListNode {
 *     int label;
 *     RandomListNode *next, *random;
 *     RandomListNode(int x) : label(x), next(NULL), random(NULL) {}
 * };
 */
class Solution {
public:
    RandomListNode *copyRandomList(RandomListNode *head) {
        unordered_map&lt;RandomListNode*, RandomListNode*&gt; tbl;
        auto it = end(tbl); RandomListNode dummy(0); auto p = head, q = &amp;dummy;
        while (p) {
            it = tbl.find(p);
            if (it != end(tbl)) q-&gt;next = it-&gt;second;
            else                tbl[p] = q-&gt;next = new RandomListNode(p-&gt;label);
            q = q-&gt;next;
            if (!p-&gt;random) { p = p-&gt;next; continue; }
            it = tbl.find(p-&gt;random);
            if (it != end(tbl)) q-&gt;random = it-&gt;second;
            else                tbl[p-&gt;random] = q-&gt;random = new RandomListNode(p-&gt;random-&gt;label);
            p = p-&gt;next;
        }
        return dummy.next;
    }
};
</code></pre>

<h2 id="139-word-break">139. Word Break</h2>

<p>link: <a href="https://leetcode.com/problems/word-break/description/">https://leetcode.com/problems/word-break/description/</a></p>

<pre><code class="language-cpp">class Solution {
public:
    bool wordBreak(string &amp;s, unordered_set&lt;string&gt;&amp; dict) {
        TrieNode root, *node;
        for (auto&amp; word : dict) {
            node = &amp;root;
            for (auto c : word) {
                char i = c - 'a';
                if (node-&gt;next[i] == nullptr) node-&gt;next[i] = new TrieNode;
                node = node-&gt;next[i];
            }
            node-&gt;flag = 1;
        }
        
        int len = s.length(); vector&lt;vector&lt;int&gt;&gt; prev(len, vector&lt;int&gt;());
        for (int l=0; l&lt;len; l++) {
            node = &amp;root;
            if (l==0 || !prev[l-1].empty()) for (int h=l; h&lt;len; h++) {
                char i = s[h] - 'a';
                if (node-&gt;next[i] == nullptr) break;
                node = node-&gt;next[i];
                if (node-&gt;flag == 1) {
                    prev[h].push_back(l);
                    if (h==len-1) return true;
                }
            }
        }
        
        return false;
    }
    
    struct TrieNode {
        int flag; TrieNode* next[26];
        TrieNode() { flag = 0; fill_n(next, 26, nullptr); }
        ~TrieNode() { for(auto node : next) if (node) delete node; }
    };
};
</code></pre>

<h2 id="140-word-break-ii">140. Word Break II</h2>

<p>link: <a href="https://leetcode.com/problems/word-break-ii/description/">https://leetcode.com/problems/word-break-ii/description/</a></p>

<pre><code class="language-cpp">class Solution {
public:
    vector&lt;string&gt; wordBreak(string &amp;s, unordered_set&lt;string&gt;&amp; dict) {
        TrieNode root, *node;
        for (auto &amp;word : dict) {
            node = &amp;root;
            for (auto c=word.rbegin(); c!=word.rend(); c++) {
                int i = *c - 'a';
                if (node-&gt;next[i] == nullptr) node-&gt;next[i] = new TrieNode();
                node = node-&gt;next[i];
            }
            node-&gt;flag = 1;
        }
        
        int len = s.length(); vector&lt;vector&lt;int&gt;&gt; next(len, vector&lt;int&gt;());
        for (int h=len-1; h&gt;=0; h--) {
            node = &amp;root;
            if (h==len-1 || !next[h+1].empty()) for (int l=h; l&gt;=0; l--) {
                int i = s[l] - 'a';
                if (node-&gt;next[i] == nullptr) break;
                node = node-&gt;next[i];
                if (node-&gt;flag == 1) next[l].push_back(h);
            }
        }
        
        vector&lt;string&gt; result; string path;
        buildSentences(s, next, 0, path, result);
        return move(result);
    }
    
    void buildSentences(string &amp;s, vector&lt;vector&lt;int&gt;&gt;&amp; next, int l, string&amp; path, vector&lt;string&gt;&amp; result) {
        if (l == s.length()) { path.pop_back(); result.push_back(move(path)); return ; }
        for (auto h : next[l]) {
            string newp = path; newp.append(s.substr(l,h-l+1)); newp.push_back(' ');
            buildSentences(s, next, h+1, newp, result);
        }
    }
    
    struct TrieNode {
        int flag; TrieNode *next[26];
        TrieNode() { flag = 0; fill_n(next, 26, nullptr); }
        ~TrieNode() { for (auto p : next) if (p) delete p; } 
    };
};
</code></pre>
    </div>

    
    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">amendgit</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">2018-09-18</span>
  </p>
  
  
</div>

    
    

    <footer class="post-footer">
      <div class="post-tags">
          
          <a href="/tags/leetcode/">leetcode</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/read/spring-in-action/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Spring in Action</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/security/buffer-overflow/">
            <span class="next-text nav-default">信息安全之缓存区溢出漏洞</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:shijian0912@163.com" class="iconfont icon-email" title="email"></a>
      <a href="http://localhost:1313" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
      <a href="http://localhost:1313" class="iconfont icon-twitter" title="twitter"></a>
      <a href="http://localhost:1313" class="iconfont icon-facebook" title="facebook"></a>
      <a href="http://localhost:1313" class="iconfont icon-linkedin" title="linkedin"></a>
      <a href="http://localhost:1313" class="iconfont icon-google" title="google"></a>
      <a href="http://localhost:1313" class="iconfont icon-github" title="github"></a>
      <a href="http://localhost:1313" class="iconfont icon-weibo" title="weibo"></a>
      <a href="http://localhost:1313" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="http://localhost:1313" class="iconfont icon-douban" title="douban"></a>
      <a href="http://localhost:1313" class="iconfont icon-pocket" title="pocket"></a>
      <a href="http://localhost:1313" class="iconfont icon-tumblr" title="tumblr"></a>
      <a href="http://localhost:1313" class="iconfont icon-instagram" title="instagram"></a>
  <a href="http://localhost:1313/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    
      2017 - 
    2019
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">amendgit</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>








</body>
</html>
