<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Leetcode Solutions 041 060 - amendgit`s blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="amendgit" />
  <meta name="description" content="本文用来记录我的leetcode解题报告，用于之后的代码优化、查阅和复习。这里是第41题到第60题。

" />

  <meta name="keywords" content="amendgit, blog" />






<meta name="generator" content="Hugo 0.48" />


<link rel="canonical" href="http://localhost:1313/post/leetcode/leetcode-solutions-041-060/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">







<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="Leetcode Solutions 041 060" />
<meta property="og:description" content="本文用来记录我的leetcode解题报告，用于之后的代码优化、查阅和复习。这里是第41题到第60题。

" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/post/leetcode/leetcode-solutions-041-060/" /><meta property="article:published_time" content="2018-08-01T11:33:16&#43;08:00"/>
<meta property="article:modified_time" content="2018-08-01T11:33:16&#43;08:00"/>
<meta itemprop="name" content="Leetcode Solutions 041 060">
<meta itemprop="description" content="本文用来记录我的leetcode解题报告，用于之后的代码优化、查阅和复习。这里是第41题到第60题。

">


<meta itemprop="datePublished" content="2018-08-01T11:33:16&#43;08:00" />
<meta itemprop="dateModified" content="2018-08-01T11:33:16&#43;08:00" />
<meta itemprop="wordCount" content="5192">



<meta itemprop="keywords" content="leetcode," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Leetcode Solutions 041 060"/>
<meta name="twitter:description" content="本文用来记录我的leetcode解题报告，用于之后的代码优化、查阅和复习。这里是第41题到第60题。

"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">amendgit&#39;s blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">amendgit&#39;s blog</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Leetcode Solutions 041 060</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-08-01 </span>
        
        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#41-first-missing-positive">41. First Missing Positive</a></li>
<li><a href="#42-trapping-rain-water">42. Trapping Rain Water</a></li>
<li><a href="#43-multiply-strings">43. Multiply Strings</a></li>
<li><a href="#44-wildcard-matching">44. Wildcard Matching</a></li>
<li><a href="#45-jumps-game-ii">45. Jumps Game II</a></li>
<li><a href="#46-permutations">46. Permutations</a></li>
<li><a href="#47-permutations-ii">47. Permutations II</a></li>
<li><a href="#48-rotate-image">48. Rotate Image</a></li>
<li><a href="#49-group-anagrams">49. Group Anagrams</a></li>
<li><a href="#50-pow-x-n">50. Pow(x, n)</a></li>
<li><a href="#51-n-queens">51. N-Queens</a></li>
<li><a href="#52-n-queens-ii">52. N-Queens II</a></li>
<li><a href="#53-maxsubarray">53. MaxSubArray</a></li>
<li><a href="#54-spiral-matrix">54. Spiral Matrix</a></li>
<li><a href="#55-jump-game">55. Jump Game</a></li>
<li><a href="#56-merge-intervals">56.Merge Intervals</a></li>
<li><a href="#57-insert-interval">57. Insert Interval</a></li>
<li><a href="#58-length-of-last-word">58. Length of Last Word</a></li>
<li><a href="#59-sprial-matrix-ii">59. Sprial Matrix II</a></li>
<li><a href="#60-permutation-sequence">60. Permutation Sequence</a></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    

    
    <div class="post-content">
      <p>本文用来记录我的leetcode解题报告，用于之后的代码优化、查阅和复习。这里是第41题到第60题。</p>

<p></p>

<h2 id="41-first-missing-positive">41. First Missing Positive</h2>

<p>链接：<a href="https://leetcode.com/problems/first-missing-positive/">https://leetcode.com/problems/first-missing-positive/</a></p>

<p>思路：遍历数组将数值x放置到对应的下标x-1上，然后遍历找到第一个无序的数字，返回下标加1。</p>

<pre><code class="language-cpp">class Solution {
public:
    int firstMissingPositive(vector&lt;int&gt;&amp; nums) {
        int len=nums.size(), i=0;
        while(i &lt; len) {
            if (nums[i]&gt;0 &amp;&amp; nums[i]&lt;=len) swap(nums[nums[i]-1], nums[i]);
            if (nums[i]&lt;=0 || nums[i]&gt;len || nums[nums[i]-1]==nums[i]) ++i;
        }
        for (i=0; i&lt;len; ++i) if (nums[i] != i+1) break;
        return i+1;
    }
};
</code></pre>

<pre><code class="language-cpp">class Solution {
public:
    int firstMissingPositive(vector&lt;int&gt;&amp; nums) {
        int len=nums.size(), i=0; vector&lt;int&gt; sort(len, 0);
        for (i=0; i&lt;len; i++) if (nums[i]&gt;0 &amp;&amp; nums[i]&lt;=len) sort[nums[i]-1] = nums[i];
        for (i=0; i&lt;len; ++i) if (sort[i] != i+1) break;
        return i+1;
    }
};
</code></pre>

<h2 id="42-trapping-rain-water">42. Trapping Rain Water</h2>

<p>链接：<a href="https://leetcode.com/problems/trapping-rain-water/discuss/">https://leetcode.com/problems/trapping-rain-water/discuss/</a></p>

<p>思路：用栈来跟踪两个能存水的bar的索引。</p>

<ul>
<li>当栈顶比当前bar的要矮时，说明还没遇到合适的bar，先压栈。</li>
<li>当栈顶比当前的bar要高时，则弹出栈顶，一直到和当前的bar略高的元素。

<ul>
<li>如果某次出栈以后，栈为空，则说明cur要比栈里所有的bar都高，可以计算两者之间的高度了。</li>
</ul></li>
<li>如果一直遇不到更高的bar，说明栈里存在更高的元素，但是可以通过计算栈里相邻的元素之间的水量来计算总水量。</li>
</ul>

<pre><code class="language-cpp">class Solution {
public:
    int trap(vector&lt;int&gt;&amp; heights) {
        int cur = 0, low = 0, sum = 0;
        stack&lt;int&gt; s; s.push(cur++);
        while (cur &lt; heights.size()) {
            if      (heights[s.top()] &gt;  heights[cur]) { s.push(cur++); }
            else if (heights[s.top()] &lt;= heights[cur]) { 
                low = s.top(); s.pop(); 
                if (s.empty()) { 
                    (cur - low &gt; 1) &amp;&amp; (sum += trap(heights, low, cur)); 
                    s.push(cur++); 
                }
            }
        }
        
        cur = s.top(); s.pop();
        while (!s.empty()) {
            low =  s.top(); s.pop();
            sum += trap(heights, low, cur);
            cur =  low;
        }
        
        return sum;
    }
    
    int trap(vector&lt;int&gt;&amp; heights, int low, int cur) {
        int sum = 0; int bar = min(heights[low], heights[cur]);
        for (int i = low+1; i &lt; cur; i++)  sum += bar - heights[i];
        return sum;
    } 
};
</code></pre>

<p>看discuss里，还有个非常巧妙的思路。可以这么理解，假设在最右侧存在一个最高的bar，比数组里所有的都要高。那么计算的过程就变得很简单了，只要从左向右扫描，然后记录目前扫描过程中遇到的最高的bar。然后，与当前扫描的bar相减就得到了想要的数了。</p>

<p>把这个思路略微变化一下，只需要确定前面存在比当前扫描的bar都更高的bar，然后记录一个扫描过程中遇到的最高的bar。就可以通过相减的方式计算最终值了。而确保前面存在更高的bar的方式，是通过左右来回切换扫描，然后扫过更小的那个值，就能保证对面存在更高的bar值了。然后，只要用一个bar记录当前两端夹逼过程中较小的那一侧的bar值就可以了。</p>

<pre><code class="language-cpp">class Solution {
public:
    int trap(vector&lt;int&gt;&amp; heights) {
        int L = 0, R = heights.size()-1, bar = 0, sum = 0;
        while (L &lt; R) {
            int cur = heights[heights[L] &lt; heights[R] ? L++ : R--];
            bar = max(bar, cur);
            sum += bar - cur;
        }
        return sum;
    }
};
</code></pre>

<p>还有一种理解简单的思路，先找到一个最高点，然后分别从左边和从右边向中间扫描，这个时候只要记住一个扫描遇到的最高的bar，就是存水的较短的那个bar。</p>

<pre><code class="language-cpp">class Solution {
public:
    int trap(vector&lt;int&gt;&amp; heights) {
        int peak = 0, sum = 0;
        for (int i=0; i&lt;heights.size(); i++) 
            if (heights[i] &gt; heights[peak]) peak = i;
        for (int i=0, bar=0; i&lt;peak; i++) {
            bar = max(heights[i], bar);
            sum += bar - heights[i];
        }
        for (int i=heights.size()-1, bar=0; i&gt;peak; i--) {
            bar = max(heights[i], bar);
            sum += bar - heights[i];
        }
        return sum;
    }
};
</code></pre>

<p>感觉这题挺不错的，能测智商。</p>

<h2 id="43-multiply-strings">43. Multiply Strings</h2>

<p>链接：<a href="https://leetcode.com/problems/multiply-strings/">https://leetcode.com/problems/multiply-strings/</a></p>

<p>思路：细节考察，模拟乘法的计算过程。</p>

<pre><code class="language-cpp">class Solution {
public:
    string multiply(string num1, string num2) {
        if (num1==&quot;0&quot; || num2==&quot;0&quot;) return &quot;0&quot;;
        int carry=0, len1=num1.length(), len2=num2.length(); string result;
        for (int i=len1-1; i&gt;=0; --i) {
            int k=len1-1-i, j=len2-1;
            while (j&gt;=0 || carry) {
                int tmp = 0;
                if (j&gt;=0) tmp = (num1[i]-'0') * (num2[j]-'0');
                if (k&gt;=result.length()) result.push_back('0');
                tmp += carry+result[k]-'0'; carry = tmp/10; tmp = tmp%10;
                result[k++] = tmp + '0';
                --j;
            } 
        }
        reverse(result.begin(), result.end());
        return move(result);
    }
};
</code></pre>

<pre><code class="language-cpp">class Solution {
public:
    string multiply(string num1, string num2) {
        if (num1==&quot;0&quot; || num2==&quot;0&quot;) return &quot;0&quot;;
        reverse(num1.begin(), num1.end()); reverse(num2.begin(), num2.end());
        int carry=0; string result(num1.size()+num2.size(), '0');
        for (int i=0; i&lt;num1.length(); ++i) {
            int k=i, j=0;
            while (j&lt;num2.length() || carry) {
                int tmp = 0;
                if (j&lt;num2.length()) tmp = (num1[i]-'0') * (num2[j]-'0');
                tmp += carry+result[k] - '0'; carry = tmp/10; tmp = tmp%10;
                result[k++] = tmp + '0';
                j++;
            } 
        }
        reverse(result.begin(), result.end());
        int l=0; while (result[l]=='0') l++;
        return result.substr(l);
    }
};
</code></pre>

<h2 id="44-wildcard-matching">44. Wildcard Matching</h2>

<p>用深搜，提示超时：</p>

<pre><code class="language-c++">class Solution {
public:
    bool isMatch(string s, string p) {
        const int slen = s.length(), plen = p.length();
        if ((slen==0 &amp;&amp; plen==0) || (slen==0 &amp;&amp; p==&quot;*&quot;)) return true;
        return DFS(s, 0, p, 0);
    }
    
    bool DFS(const string&amp; s, int si, const string&amp; p,int pi) {
        if (si == s.length() &amp;&amp; pi == p.length()) return true;
        if (pi == p.length()) return false;
        if (p[pi] == '*') for (int i=0; si+i&lt;=s.length(); i++) if (DFS(s, si+i, p, pi+1)) return true; 
        if ((p[pi] == '?' || s[si] == p[pi]) &amp;&amp; DFS(s, si+1, p, pi+1)) return true;
        return false;
    }
};
</code></pre>

<p>用动态规划的思路，dp[i+1][j+1] &lt;=&gt; s[0,i] =~ p[0,j]。那么，dp[i+1][j+1]可以通过以下来推导：</p>

<ul>
<li>dp[i][j] 且 ( s[i]==p[j] 或 p[j] == &lsquo;*&rsquo; 或 p[j] == &lsquo;?&rsquo; )</li>
<li>(dp[i+1][j] 或 dp[i][j+1]) 或 p[j] == &lsquo;*&lsquo;</li>
</ul>

<p>其中部分二的情况，其实是在1中覆盖了：如 <code>[acc, a*c]</code>当处于<code>[acc, a*]</code>时，2的推导不满足，因为p[j]不等于<code>*</code>，但是在<code>[ac, a*]</code>时，满足1的情况。只要有一个推导能推导出来就可以了。</p>

<p>初始时，需要初始化掉第一行和第一列的值。dp[0][0]，由题意[ , ]结果是1.</p>

<p>第一行：当p始终为&rdquo;*&ldquo;时，值就会为1，如：<code>[ , *]</code>、<code>[ , **]</code>、<code>[ , ***]</code></p>

<p>第一列：空的p匹配任何非空的s，结果都是0</p>

<pre><code class="language-cpp">class Solution {
public:
    bool isMatch(string s, string p) {
        const int slen = s.length(), plen = p.length();
        vector&lt;vector&lt;int&gt;&gt; dp(slen+1, vector&lt;int&gt;(plen+1, 0)); dp[0][0]   = 1;
        for (int i=0; i&lt;slen; i++)                              dp[i+1][0] = 0;
        for (int j=0; j&lt;plen; j++) if (p[j]=='*' &amp;&amp; dp[0][j])   dp[0][j+1] = 1;
        for (int i=0; i&lt;slen; i++) for (int j=0; j&lt;plen; j++) {
            dp[i+1][j+1] = dp[i][j] &amp;&amp; (s[i]==p[j] || p[j]=='?' || p[j]=='*');
            dp[i+1][j+1] = dp[i+1][j+1] || p[j]=='*' &amp;&amp; (dp[i+1][j] || dp[i][j+1]);
        }
        return dp[slen][plen];
    }
};
</code></pre>

<p>稍微做点优化，因为dp默认值是0，所以很多操作可以不要：</p>

<pre><code class="language-cpp">class Solution {
public:
    bool isMatch(string s, string p) {
        const int slen = s.length(), plen = p.length();
        vector&lt;vector&lt;int&gt;&gt; dp(slen+1, vector&lt;int&gt;(plen+1, 0)); dp[0][0] = 1;
        for (int j=0; j&lt;plen; j++) if (p[j]=='*') dp[0][j+1] = 1; else break;
        for (int i=0; i&lt;slen; i++) for (int j=0; j&lt;plen; j++) {
            dp[i+1][j+1] = dp[i][j] &amp;&amp; (s[i]==p[j] || p[j]=='?' || p[j]=='*');
            dp[i+1][j+1] = dp[i+1][j+1] || p[j]=='*' &amp;&amp; (dp[i+1][j] || dp[i][j+1]);
        }
        return dp[slen][plen];
    }
};
</code></pre>

<h2 id="45-jumps-game-ii">45. Jumps Game II</h2>

<p>link: <a href="https://leetcode.com/problems/jump-game-ii/description/">https://leetcode.com/problems/jump-game-ii/description/</a></p>

<p>1.45%，很慢的一个解决方法。</p>

<pre><code class="language-cpp">class Solution {
public:
    int jump(vector&lt;int&gt;&amp; nums) {
        if (nums.size() == 1) return 0;
        int last = nums.size()-1, jumps = 0, i = 0;
        while (true) {
            for (i=0; i&lt;last; i++) if (nums[i] + i &gt;= last) break;
            last = i, jumps++;
            if (i == 0) return jumps;
        }
        return jumps;
    }
};
</code></pre>

<p>discuss里有一个很快的办法，单次循环。nums[0] + 0，是第一步能到的最远的位置。在(0, nums[0]+0]区间内，都是第一步能reach的位置，计算这中间的第i2个元素跳的最远，位置是nums[i2]+i2，那么在(nums[0]+0, nums[i2]+i2]，是第二步能跳到的区间。再继续下去，就能计算最终到达的位置。</p>

<pre><code class="language-cpp">class Solution {
public:
    int jump(vector&lt;int&gt;&amp; nums) {
        int jumps = 0, reached = 0, reaching = 0;
        for (int i = 0; i &lt; nums.size()-1; i++) {
            reaching = max(reaching, i + nums[i]);
            if (i == reached) {
                jumps++;
                reached = reaching;
            }
        }
        return jumps;
    }
};
</code></pre>

<h2 id="46-permutations">46. Permutations</h2>

<p>链接：<a href="https://leetcode.com/problems/permutations/description/">https://leetcode.com/problems/permutations/description/</a></p>

<p>思路：f(0, [1,2,3]) = f(1, [1,2,3]) + f(1, [2,1,3]) + f(1, [3,2,1]);</p>

<p>递归求解即可，即[1,2,3]的全排列，等于将各个元素分别提到第一个，然后和剩余元素全排列的结果拼接在一起。</p>

<pre><code class="language-cpp">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) {
        vector&lt;vector&lt;int&gt;&gt; result;
        dfs(nums, 0, result);
        return result;
    }
    
    void dfs(vector&lt;int&gt;&amp; nums, int p, vector&lt;vector&lt;int&gt;&gt;&amp; result) {
        if (p == nums.size()-1) { result.push_back(nums); return; }
        for (int i=p; i&lt;nums.size(); i++) {
            swap(nums[p], nums[i]);
            dfs(nums, p+1, result);
            swap(nums[p], nums[i]);
        }
    }
};
</code></pre>

<h2 id="47-permutations-ii">47. Permutations II</h2>

<p>链接：<a href="https://leetcode.com/problems/permutations/description/">https://leetcode.com/problems/permutations/description/</a></p>

<p>思路：和46题比起来，多了重复的数字，因此要加上去重的逻辑，已经swap过的值就不再swap了。</p>

<p>f(0, [1,1,2]) = f(1, [1,1,2]) + <del>f(1, [1,1,2])</del> + f(1, [1,2,1])</p>

<p>注意，要用哈希表，例如 [1,1,2,2]这样的情况，在f(0,&hellip;) 到 f(1, &hellip;) 递推的过程中，不仅仅1不能和1交换，1也不能和2交换。</p>

<pre><code class="language-cpp">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) {
        vector&lt;vector&lt;int&gt;&gt; result;
        dfs(nums, 0, result);
        return result;
    }
    
    void dfs(vector&lt;int&gt;&amp; nums, int p, vector&lt;vector&lt;int&gt;&gt;&amp; result) {
        if (p == nums.size()-1) { result.push_back(nums); return; }
        set&lt;int&gt; tbl;
        for (int i=p; i&lt;nums.size(); i++) {
            if (tbl.insert(nums[i]).second == false) continue;
            swap(nums[i], nums[p]);
            dfs(nums, p+1, result);
            swap(nums[i], nums[p]);
        }
    }
};
</code></pre>

<p>先排序，后去重，不知道哪出问题了</p>

<pre><code class="language-cpp">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) {
        vector&lt;vector&lt;int&gt;&gt; result;
        sort(begin(nums), end(nums));
        dfs(nums, 0, result);
        return result;
    }
    
    void dfs(vector&lt;int&gt;&amp; nums, int p, vector&lt;vector&lt;int&gt;&gt;&amp; result) {
        if (p == nums.size()-1) { result.push_back(nums); return; }
        for (int i=p; i&lt;nums.size(); i++) {
            if (i&gt;p &amp;&amp; nums[i]==nums[i-1]) continue;
            swap(nums[i], nums[p]);
            dfs(nums, p+1, result);
            swap(nums[i], nums[p]);
        }
    }
};
</code></pre>

<h2 id="48-rotate-image">48. Rotate Image</h2>

<p>链接：<a href="https://leetcode.com/problems/rotate-image/description/">https://leetcode.com/problems/rotate-image/description/</a></p>

<p>思路：先沿着主对角线交换，再沿着中轴线左右交换一次，注意不要重复交换了。</p>

<pre><code class="language-cpp">class Solution {
public:
    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; mat) {
        if (mat.empty()) return;
        const int ROW = mat.size(), COL = mat[0].size();
        for (int i=0; i&lt;ROW; i++) for (int j=i+1; j&lt;COL; j++) 
            swap(mat[i][j], mat[j][i]);
        for (int i=0; i&lt;ROW; i++) for (int j=0; j&lt;COL/2; j++) 
            swap(mat[i][j], mat[i][COL-1-j]);
    }
};
</code></pre>

<h2 id="49-group-anagrams">49. Group Anagrams</h2>

<p>链接：<a href="https://leetcode.com/problems/group-anagrams/description/">https://leetcode.com/problems/group-anagrams/description/</a></p>

<p>思路：将单词按字母排序后值作为key，然后挂到哈希表下的vector中，最终取出来即可。</p>

<pre><code class="language-cpp">class Solution {
public:
    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) {
        unordered_map&lt;string, vector&lt;string&gt;&gt; hashmap;
        for (auto &amp;str : strs) { 
            auto tmp = str; sort(begin(tmp), end(tmp)); 
            hashmap[tmp].push_back(str); 
        }
        vector&lt;vector&lt;string&gt;&gt; result;
        for (auto &amp;pair : hashmap) result.push_back(pair.second);
        return move(result);
    }
};
</code></pre>

<h2 id="50-pow-x-n">50. Pow(x, n)</h2>

<p>emmm 超时了，300 / 304 test cases passed，下面这个case超时了</p>

<pre><code>Last executed input:
1.00000
-2147483648
</code></pre>

<p>讲道理不应该啊。。。</p>

<pre><code class="language-cpp">class Solution {
public:
    double myPow(double x, int n) {
        double result = 1.f;
        int save = n;
        n = abs(n);
        while (n != 0) {
            (n &amp; 1 != 0) &amp;&amp; (result *= x);
            x *= x; n &gt;&gt;= 1;
        }
        if (save &lt; 0) result = 1.f / result;
        return result;
    }
};
</code></pre>

<p>好吧，找到原因了，INT_MIN的abs。。。还是INT_MIN.</p>

<pre><code>INT_MAX: 2147483647
INT_MIN: -2147483648
abs(INT_MIN): -2147483648
</code></pre>

<p>换成下面的可以了</p>

<pre><code class="language-cpp">class Solution {
public:
    double myPow(double x, int n) {
        double result = 1.f;
        long l = abs((long)n);
        while (l != 0) {
            (l &amp; 1 != 0) &amp;&amp; (result *= x);
            x *= x; l &gt;&gt;= 1;
        }
        if (n &lt; 0) result = 1.f / result;
        return result;
    }
};
</code></pre>

<h2 id="51-n-queens">51. N-Queens</h2>

<p>链接：<a href="https://leetcode.com/problems/n-queens/description/">https://leetcode.com/problems/n-queens/description/</a></p>

<p>思路：queen所在的位置的水平、竖直、45度斜线、-45度斜线上不能存在另外一个queen。因此，我们逐行搜索，深度优先。用vertical记录第c列是否有其他queen存在、diag记录同45度上是否有其他queen存在，antidiag记录-45度斜线上是否存在其他queen。</p>

<p>有一个小技巧：在同一个45度线上的，r+c的值相同。在同一个-45度上的，可以通过水平翻转，[r+c] -&gt; [r,n-1-c]，然后他们的家和也是相同的了。</p>

<pre><code class="language-cpp">class Solution {
public:
    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) {
        vector&lt;vector&lt;string&gt;&gt; result; vector&lt;int&gt; path(n, 0);
        vector&lt;int&gt; vertical(n, 0), diag(n+n, 0), antidiag(n+n, 0);
        dfs(0, n, path, vertical, diag, antidiag, result);
        return result;
    }

    void dfs(int r, int n, vector&lt;int&gt;&amp; path, vector&lt;int&gt;&amp; vertical, vector&lt;int&gt;&amp; diag, 
            vector&lt;int&gt;&amp; antidiag, vector&lt;vector&lt;string&gt;&gt;&amp; result) {
        if (r == n) {
            vector&lt;string&gt; ans(n, string(n, '.')); for (int i=0; i&lt;n; i++) ans[i][path[i]] = 'Q';
            result.push_back(ans);
            return;
        }
        for (int c=0; c&lt;n; c++) {
            if (vertical[c] || diag[r+c] || antidiag[r+n-1-c]) continue;
            vertical[c] = diag[r+c] = antidiag[r+n-1-c] = 1;
            path[r] = c;
            dfs(r+1, n, path, vertical, diag, antidiag, result);
            path[r] = 0;
            vertical[c] = diag[r+c] = antidiag[r+n-1-c] = 0;
        }
    }
};
</code></pre>

<h2 id="52-n-queens-ii">52. N-Queens II</h2>

<p>链接：<a href="https://leetcode.com/problems/n-queens-ii/description/">https://leetcode.com/problems/n-queens-ii/description/</a></p>

<p>思路：类似51题，区别在于统计不同ans的数量，感觉还简单一些。</p>

<pre><code class="language-cpp">class Solution {
public:
    int totalNQueens(int n) {
        vector&lt;int&gt; vertical(n, 0), diag(n+n, 0), antidiag(n+n, 0); int total = 0;
        dfs(0, n, vertical, diag, antidiag, total);
        return total;
    }
    
    void dfs(int r, int n, vector&lt;int&gt;&amp; vertical, vector&lt;int&gt;&amp; diag, vector&lt;int&gt;&amp; antidiag, int&amp; total) {
        if (r == n) { total++; return; }
        for (int c=0; c&lt;n; c++) {
            if (vertical[c] || diag[r+c] || antidiag[r+n-1-c]) continue;
            vertical[c] = diag[r+c] = antidiag[r+n-1-c] = 1;
            dfs(r+1, n, vertical, diag, antidiag, total);
            vertical[c] = diag[r+c] = antidiag[r+n-1-c] = 0;
        }
    }
};
</code></pre>

<h2 id="53-maxsubarray">53. MaxSubArray</h2>

<p>链接: <a href="https://leetcode.com/problems/maximum-subarray/description/">https://leetcode.com/problems/maximum-subarray/description/</a></p>

<p>思路：动态规划
last(i)表示在nums[0&hellip;i]中，尾部加和的最大值。
maxsum(i)表示在nums[0&hellip;i]中，最大子数组的和的值。</p>

<p>last(i) = max(last(i-1)+nums(i), nums(i)) , 只有当加上nums[i]后，值变得更小了，才会将last(i)更新为nums[i]
maxsum(i) = max(maxsum(i-1), last(i))</p>

<p>要注意一下，子数组是否允许为空。</p>

<pre><code class="language-cpp">class Solution {
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums) {
        if (nums.empty()) return 0;
        int maxsum=nums[0], last=nums[0];
        for (int i=1; i&lt;nums.size(); i++) {
            last += nums[i];
            last = max(last, nums[i]);
            maxsum = max(maxsum, last);
        }
        return maxsum;
    }
};
</code></pre>

<h2 id="54-spiral-matrix">54. Spiral Matrix</h2>

<p>链接：<a href="https://leetcode.com/problems/spiral-matrix/">https://leetcode.com/problems/spiral-matrix/</a></p>

<p>思路：用(rb, cb, re, ce)表示矩阵的矩形区域，便利矩形边界和动态更新矩形区域的大小。在向左便利和向上便利的时候，需要判断前面的操作过程中有没有使得矩形失效。</p>

<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        vector&lt;int&gt; result;
        if (matrix.empty()) return result;
        int rb=0, cb=0, re=matrix.size()-1, ce=matrix[0].size()-1, i;
        result.reserve((re+1)*(ce+1)); 
        while (cb&lt;=ce &amp;&amp; rb&lt;=re) {
            for (i=cb; i&lt;=ce; ++i) result.push_back(matrix[rb][i]); rb++;
            for (i=rb; i&lt;=re; ++i) result.push_back(matrix[i][ce]); ce--;
            if (rb &lt;= re) for (i=ce; i&gt;=cb; --i) result.push_back(matrix[re][i]); re--;
            if (cb &lt;= ce) for (i=re; i&gt;=rb; --i) result.push_back(matrix[i][cb]); cb++;
        }
        return move(result);
    }
};
</code></pre>

<h2 id="55-jump-game">55. Jump Game</h2>

<p>链接：<a href="https://leetcode.com/problems/jump-game/description/">https://leetcode.com/problems/jump-game/description/</a></p>

<p>思路：计算每一格子能到达的最远位置，然后记录遍历以来能到达的最远位置，只要在最远位置内的都是可到达的点。然后判断最远位置是否能到达终点，如果可以则返回true，反之返回false。</p>

<pre><code class="language-cpp">class Solution {
public:
    bool canJump(vector&lt;int&gt;&amp; nums) {
        int reach=0, n=nums.size();
        for (int i=0; i&lt;n &amp;&amp; i&lt;=reach; i++) {
            reach = max(i+nums[i], reach);
            if (reach &gt;= n-1) return true;
        }
        return false;
    }
};
</code></pre>

<h2 id="56-merge-intervals">56.Merge Intervals</h2>

<p>链接：<a href="https://leetcode.com/problems/merge-intervals/description/">https://leetcode.com/problems/merge-intervals/description/</a></p>

<p>思路：先排序，再遍历合并就可以了。</p>

<pre><code class="language-cpp">/**
 * Definition for an interval.
 * struct Interval {
 *     int start;
 *     int end;
 *     Interval() : start(0), end(0) {}
 *     Interval(int s, int e) : start(s), end(e) {}
 * };
 */
class Solution {
public:
    vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; I) {
        if (I.size() &lt;= 1) return I;
        sort(begin(I), end(I), [](const Interval&amp; l, const Interval&amp; r) {
            return l.start &lt; r.start;
        });
        Interval curr = I.front(), next; vector&lt;Interval&gt; result;
        for (int i=1; i&lt;I.size(); i++) {
            next = I[i];
            if (curr.end &gt;= next.start) { curr.end = max(curr.end, next.end);  }
            else                        { result.push_back(curr); curr = next; }
        }
        result.push_back(curr);
        return result;
    }
};
</code></pre>

<h2 id="57-insert-interval">57. Insert Interval</h2>

<p>链接：<a href="https://leetcode.com/problems/insert-interval/">https://leetcode.com/problems/insert-interval/</a></p>

<p>思路：先找到与start相交的interval，然后开始合并，直到与end相交的interval，再放压入剩余的interval.</p>

<pre><code class="language-cpp">/**
 * Definition for an interval.
 * struct Interval {
 *     int start;
 *     int end;
 *     Interval() : start(0), end(0) {}
 *     Interval(int s, int e) : start(s), end(e) {}
 * };
 */
class Solution {
public:
    vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; I, Interval i) {
        vector&lt;Interval&gt; result; int p=0, len=I.size();
        while (p&lt;len &amp;&amp; I[p].end&lt;i.start) result.push_back(I[p++]);
        while (p&lt;len &amp;&amp; I[p].start&lt;=i.end) { 
            i.start = min(I[p].start, i.start); 
            i.end   = max(I[p].end  , i.end); 
            p++; 
        } 
        result.push_back(i);
        while (p &lt; len) result.push_back(I[p++]);
        return move(result);
    }
};
</code></pre>

<h2 id="58-length-of-last-word">58. Length of Last Word</h2>

<p>链接：<a href="https://leetcode.com/problems/length-of-last-word/description/">https://leetcode.com/problems/length-of-last-word/description/</a></p>

<p>思路：需要注意防止尾部有空格，没有其他要注意的了。</p>

<pre><code class="language-cpp">class Solution {
public:
    int lengthOfLastWord(const string&amp; s) {
        int result = 0; int p = s.length()-1;
        while (p &gt;= 0 &amp;&amp; isspace(s[p])) p--;
        while (p &gt;= 0 &amp;&amp; isalpha(s[p])) { p--; result++; }
        return move(result);
    }
};
</code></pre>

<h2 id="59-sprial-matrix-ii">59. Sprial Matrix II</h2>

<p>链接：<a href="https://leetcode.com/problems/spiral-matrix-ii/description/">https://leetcode.com/problems/spiral-matrix-ii/description/</a></p>

<p>思路：设有四根线在上下左右四侧，遍历一条边之后，就将对应的边增加。</p>

<pre><code class="language-cpp">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) {
        vector&lt;vector&lt;int&gt;&gt; result(n, vector&lt;int&gt;(n, 0));
        int rb=0, re=n-1, cb=0, ce=n-1, p=1;
        for (int i=0; i&lt;(n+1)/2; i++) {
            for (int c=cb; c&lt;=ce; c++) result[rb][c] = p++; rb++;
            for (int r=rb; r&lt;=re; r++) result[r][ce] = p++; ce--;
            for (int c=ce; c&gt;=cb; c--) result[re][c] = p++; re--;
            for (int r=re; r&gt;=rb; r--) result[r][cb] = p++; cb++;
        }
        return move(result);
    }
};
</code></pre>

<h2 id="60-permutation-sequence">60. Permutation Sequence</h2>

<p>链接：<a href="https://leetcode.com/problems/permutation-sequence/description/">https://leetcode.com/problems/permutation-sequence/description/</a></p>

<p>思路：共有 n * (n-1) * (n-2) * &hellip; * 1 个数，第一层可以分为n个(n-1)!，第一位分别以1 2 3 &hellip; n，依次内推。因此，可以先计算出在哪个区间内，并将每一层数字追加到result里。</p>

<pre><code class="language-cpp">class Solution {
public:
    string getPermutation(int n, int k) {
        int f = 1; vector&lt;char&gt; nums; string result; k = k - 1;
        for (int i=1; i&lt;= n; i++) { f *= i; nums.push_back(i+'0'); }
        while (nums.size() &gt; 1 &amp;&amp; k != 0) {
            f /= nums.size();
            int i = k / f; k = k % f;
            result.push_back(nums[i]); 
            nums.erase(begin(nums)+i);
        }
        for (char num : nums) result.push_back(num);
        return result;
    }
};
</code></pre>
    </div>

    
    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">amendgit</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">2018-08-01</span>
  </p>
  
  
</div>

    
    

    <footer class="post-footer">
      <div class="post-tags">
          
          <a href="/tags/leetcode/">leetcode</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/leetcode/leetcode-solutions-061-080/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Leetcode Solutions 061 080</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/leetcode/leetcode-solutions-021-040/">
            <span class="next-text nav-default">Leetcode Solutions 021 040</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:shijian0912@163.com" class="iconfont icon-email" title="email"></a>
      <a href="http://localhost:1313" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
      <a href="http://localhost:1313" class="iconfont icon-twitter" title="twitter"></a>
      <a href="http://localhost:1313" class="iconfont icon-facebook" title="facebook"></a>
      <a href="http://localhost:1313" class="iconfont icon-linkedin" title="linkedin"></a>
      <a href="http://localhost:1313" class="iconfont icon-google" title="google"></a>
      <a href="http://localhost:1313" class="iconfont icon-github" title="github"></a>
      <a href="http://localhost:1313" class="iconfont icon-weibo" title="weibo"></a>
      <a href="http://localhost:1313" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="http://localhost:1313" class="iconfont icon-douban" title="douban"></a>
      <a href="http://localhost:1313" class="iconfont icon-pocket" title="pocket"></a>
      <a href="http://localhost:1313" class="iconfont icon-tumblr" title="tumblr"></a>
      <a href="http://localhost:1313" class="iconfont icon-instagram" title="instagram"></a>
  <a href="http://localhost:1313/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    
      2017 - 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">amendgit</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>








</body>
</html>
