<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Leetcode Solutions 001-020 - amendgit`s blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="amendgit" />
  <meta name="description" content="本文用来记录我的leetcode解题报告，用于之后的代码优化、查阅和复习。这里是第1题到第20题。

" />

  <meta name="keywords" content="amendgit, blog" />






<meta name="generator" content="Hugo 0.47.1" />


<link rel="canonical" href="http://localhost:1313/post/leetcode/leetcode-solutions-001-020/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">







<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="Leetcode Solutions 001-020" />
<meta property="og:description" content="本文用来记录我的leetcode解题报告，用于之后的代码优化、查阅和复习。这里是第1题到第20题。

" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/post/leetcode/leetcode-solutions-001-020/" /><meta property="article:published_time" content="2018-06-01T15:34:45&#43;08:00"/>
<meta property="article:modified_time" content="2018-06-01T15:34:45&#43;08:00"/>
<meta itemprop="name" content="Leetcode Solutions 001-020">
<meta itemprop="description" content="本文用来记录我的leetcode解题报告，用于之后的代码优化、查阅和复习。这里是第1题到第20题。

">


<meta itemprop="datePublished" content="2018-06-01T15:34:45&#43;08:00" />
<meta itemprop="dateModified" content="2018-06-01T15:34:45&#43;08:00" />
<meta itemprop="wordCount" content="4206">



<meta itemprop="keywords" content="leetcode," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Leetcode Solutions 001-020"/>
<meta name="twitter:description" content="本文用来记录我的leetcode解题报告，用于之后的代码优化、查阅和复习。这里是第1题到第20题。

"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">amendgit&#39;s blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">amendgit&#39;s blog</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Leetcode Solutions 001-020</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-06-01 </span>
        
        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#1-two-sum">1. Two Sum</a></li>
<li><a href="#2-add-two-numbers">2. Add Two Numbers</a></li>
<li><a href="#3-longest-substring-without-repeating-characters">3. Longest Substring Without Repeating Characters</a></li>
<li><a href="#4-median-of-two-sorted-arrays">4. Median of Two Sorted Arrays</a></li>
<li><a href="#5-longest-palindromic-substring">5. Longest Palindromic Substring</a></li>
<li><a href="#6-zig-zag-conversion">6. Zig Zag Conversion</a></li>
<li><a href="#7-reverse-integer">7. Reverse Integer</a></li>
<li><a href="#8-string-to-integer-atoi">8. String to Integer (atoi)</a></li>
<li><a href="#9-palindrome-number">9. Palindrome Number</a></li>
<li><a href="#10-regular-expression-matching">10. Regular Expression Matching</a></li>
<li><a href="#11-container-with-most-water">11. Container With Most Water</a></li>
<li><a href="#12-integer-to-roman">12. Integer to Roman</a></li>
<li><a href="#13-roman-to-integer">13. Roman To Integer</a></li>
<li><a href="#14-longest-common-prefix">14. Longest Common Prefix</a></li>
<li><a href="#15-3sum">15. 3Sum</a></li>
<li><a href="#16-3sum-closest">16. 3Sum Closest</a></li>
<li><a href="#17-letter-combinations-of-a-phone-number">17. Letter Combinations of a Phone Number</a></li>
<li><a href="#18-4sum">18. 4Sum</a></li>
<li><a href="#19-remove-nth-node-from-end-of-list">19. Remove Nth Node From End of List</a></li>
<li><a href="#20-valid-parentheses">20. Valid Parentheses</a></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    

    
    <div class="post-content">
      <p>本文用来记录我的leetcode解题报告，用于之后的代码优化、查阅和复习。这里是第1题到第20题。</p>

<p></p>

<h2 id="1-two-sum">1. Two Sum</h2>

<p>链接：<a href="https://leetcode.com/problems/two-sum/">https://leetcode.com/problems/two-sum/</a></p>

<p>思路1：暴力搜索，586ms</p>

<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        int i=0, j=i+1, len=nums.size();
        vector&lt;int&gt; result;
        for (int i=0; i&lt;len-1; ++i) for (j=i+1; j&lt;len; j++)
            if (nums[i]+nums[j] == target) { result = {i,j}; break; }
        return move(result);
    }
};
</code></pre>

<p>思路2：用hash，O(n)，用时13ms,注意如果把下面的unordered_map替换成map会耗时26ms。看来用hashtable实现的unordered_map比红黑树实现的map要快一倍多。</p>

<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        unordered_map&lt;int, int&gt; tbl; vector&lt;int&gt; result;
        for (int i=0; i&lt;nums.size(); ++i) {
            int need = target-nums[i];
            if (tbl.find(need) != tbl.end()) { result = {tbl[need],i}; break;}
            tbl[nums[i]] = i;
        }
        return move(result);
    }
};
</code></pre>

<h2 id="2-add-two-numbers">2. Add Two Numbers</h2>

<p>链接：<a href="https://leetcode.com/problems/add-two-numbers/">https://leetcode.com/problems/add-two-numbers/</a></p>

<p>思路：细节考察题，见代码。</p>

<pre><code class="language-cpp">class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        int carry = 0; ListNode result(0), *p = &amp;result;
        while (l1 || l2 || carry) {
            if (l1) { carry += l1-&gt;val; l1 = l1-&gt;next; }
            if (l2) { carry += l2-&gt;val; l2 = l2-&gt;next; }
            ListNode *n = new ListNode(carry % 10); carry /= 10;
            p-&gt;next = n; p = p-&gt;next;
        }
        return result.next;
    }
};
</code></pre>

<h2 id="3-longest-substring-without-repeating-characters">3. Longest Substring Without Repeating Characters</h2>

<p>链接：<a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">https://leetcode.com/problems/longest-substring-without-repeating-characters/</a></p>

<p>思路：使用t[256]计数。双指针l和i，i遍历直到有重复字符。计算距离i-l和最大值r。移动l消除重复字符。</p>

<pre><code class="language-cpp">class Solution {
public:
    int lengthOfLongestSubstring(string&amp; s) {
        if (s.empty()) return 0;
        int t[256], l=0, r=1, len=s.length();
        fill_n(t, 256, 0); t[s[0]]++;
        for (int i=1; i&lt;len; ++i) {
            if (t[s[i]] == 0) 
                t[s[i]]++;
            else {
                r = max(r, i-l);
                while (s[l]!=s[i]) t[s[l++]]--; l++;
            }
        }
        return max(r, len-l);
    }
};
</code></pre>

<h2 id="4-median-of-two-sorted-arrays">4. Median of Two Sorted Arrays</h2>

<p>链接：<a href="https://leetcode.com/problems/median-of-two-sorted-arrays/">https://leetcode.com/problems/median-of-two-sorted-arrays/</a></p>

<p>思路：转化问题为找到两个有序数组中第k个数的问题。排除法，取两数组中第k/2(必须保证加起来和为k)大小的数字作比较，第k大的数字肯定不在较小的那个k/2序列中。将其下标l提升k/2，转化为在l1和l2起始位置开始找第k-k/2大小的数字。</p>

<pre><code class="language-cpp">class Solution {
public:
    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
        int h1 = nums1.size(), h2 = nums2.size();
        if ((h1 + h2) % 2 != 0)
            return  kthNum(nums1, 0, nums2, 0, (h1 + h2)/2+1);
        else 
            return (kthNum(nums1, 0, nums2, 0, (h1 + h2)/2) 
                +   kthNum(nums1, 0, nums2, 0, (h1 + h2)/2+1)) / 2;
    }
    
    double kthNum(vector&lt;int&gt;&amp; nums1, int l1, vector&lt;int&gt;&amp; nums2, int l2, int k) {
        int h1 = nums1.size(), h2 = nums2.size();
        if (h1-l1 &lt; h2-l2) return kthNum(nums2, l2, nums1, l1, k);
        if (h2-l2 &lt;= 0)    return nums1[l1+k-1];
        if (k == 1)        return min(nums1[l1], nums2[l2]);
        int i2 = min(h2, l2+k/2); int i1 = l1+k-(i2-l2);
        if (nums1[i1-1] &lt; nums2[i2-1]) return kthNum(nums1, i1, nums2, l2, k-(i1-l1));
        if (nums1[i1-1] &gt; nums2[i2-1]) return kthNum(nums1, l1, nums2, i2, k-(i2-l2));
        return nums1[i1-1];
    }
};
</code></pre>

<h2 id="5-longest-palindromic-substring">5. Longest Palindromic Substring</h2>

<p>链接：<a href="https://leetcode.com/problems/longest-palindromic-substring/">https://leetcode.com/problems/longest-palindromic-substring/</a></p>

<p>思路：动态规划，设f[i,j]表示s[i,j]是否是回文字符串，<code>f[i,j] = s[i]==s[j] &amp;&amp; (i&gt;=j-1 || f[i+1,j-1])</code>。进一步发现f[i,j]依赖f[i+1,j-1]，可以优化为一维表，即<code>f[i] = s[i]==s[j] &amp;&amp; (i&gt;=j-1 || f[i+1])</code>。</p>

<pre><code class="language-cpp">class Solution {
public:
    string longestPalindrome(const string&amp; s) {
        const int len = s.length(); int l=0, h=0;
        int f[len] = {0};
        for (int j=0; j&lt;len; ++j) for (int i=0; i&lt;=j; ++i) {
            f[i] = s[i]==s[j] &amp;&amp; (i&gt;=j-1 || f[i+1]);
            if (f[i] &amp;&amp; (j-i&gt;h-l)) { l=i; h=j; }
        }
        return move(s.substr(l, h-l+1));
    }
};
</code></pre>

<h2 id="6-zig-zag-conversion">6. Zig Zag Conversion</h2>

<p>链接：<a href="https://leetcode.com/problems/zigzag-conversion/">https://leetcode.com/problems/zigzag-conversion/</a></p>

<p>思路：映射索引到对应的row的位置，然后存储在不同的string中，最后合并起来。</p>

<pre><code class="language-cpp">class Solution {
public:
    string convert(const string &amp;s, int n) {
        if (n == 1 || n &gt;= s.length()) return s;
        vector&lt;string&gt; buckets(n);
        // map form [0, 1, 2, 3, 4, 5 ...] to [0, 1, 2, 1, 0, 1 ...]
        for (int i=0; i&lt;s.length(); ++i) 
            buckets[n-1-abs(i%(n*2-2)-n+1)].push_back(s[i]);
        string result; result.reserve(s.length());
        for (auto bucket : buckets) result.append(bucket);
        return move(result);
    }
};
</code></pre>

<h2 id="7-reverse-integer">7. Reverse Integer</h2>

<p>链接：<a href="https://leetcode.com/problems/reverse-integer/">https://leetcode.com/problems/reverse-integer/</a></p>

<p>细节题，abcd，一次取d c b a，在加到result中去，result*10 + tmp。要注意符号和溢出的处理，不需要单独处理INT_MIN，因为INT_MIN和INT_MAX的reverse都不存在。</p>

<pre><code class="language-cpp">class Solution {
public:
    int reverse(int x) {
        bool flag = false; if (x &lt; 0) { flag = true; x = -x; } 
        long long result = 0;
        while (x &gt; 0) {
            int tmp = x % 10; x = x / 10;
            result = result * 10 + tmp;
        }
        if (result &gt; INT_MAX) return 0;
        if (flag) result = -result;
        return result;
    }
};
</code></pre>

<h2 id="8-string-to-integer-atoi">8. String to Integer (atoi)</h2>

<p>链接：<a href="https://leetcode.com/problems/string-to-integer-atoi/">https://leetcode.com/problems/string-to-integer-atoi/</a></p>

<p>思路：细节考察题，注意：空格、符号、溢出问题。</p>

<pre><code class="language-cpp">class Solution {
public:
    int myAtoi(const string &amp;str) {
        int i=0, sign=1; long long result=0; const int len = str.length();
        // trim spaces.
        while (i&lt;len &amp;&amp; str[i]==' ') i++;
        // handle sign.
        if      (i&lt;len &amp;&amp; str[i]=='+') i++;
        else if (i&lt;len &amp;&amp; str[i]=='-') { sign = -1; i++; }
        // convert.
        while (i&lt;len &amp;&amp; result+INT_MIN&lt;=0 &amp;&amp; isdigit(str[i])) { 
            result = result*10 + str[i] - '0'; i++; 
        }
        // handle overflow.
        if (sign==+1 &amp;&amp; result-INT_MAX&gt;=0) return INT_MAX;
        if (sign==-1 &amp;&amp; result+INT_MIN&gt;=0) return INT_MIN;
        // return.
        return (int)result * sign;
    }
};
</code></pre>

<h2 id="9-palindrome-number">9. Palindrome Number</h2>

<p>链接：<a href="https://leetcode.com/problems/palindrome-number/">https://leetcode.com/problems/palindrome-number/</a></p>

<p>思路：前后依次计算对应位置的值，然后前后对比。</p>

<pre><code class="language-cpp">class Solution {
public:
    bool isPalindrome(int x) {
        if (x &lt; 0) return false;
        int p=1, q=1;
        while (x / p &gt;= 10) p *= 10;
        while (p &gt;= q) {
            if ((x/p)%10 != (x/q)%10) return false;
            p = p / 10; q = q * 10;
        }
        return true;
    }
};
</code></pre>

<h2 id="10-regular-expression-matching">10. Regular Expression Matching</h2>

<p>链接：<a href="https://leetcode.com/problems/regular-expression-matching/">https://leetcode.com/problems/regular-expression-matching/</a></p>

<p>思路：这题状态转换比较繁，我用图简单画了下。
<img src="leanote://file/getImage?fileId=5808e2341b6f9f2c0e000000" alt="empty" /></p>

<pre><code class="language-cpp">class Solution {
public:
bool isMatch(const string &amp;s, const string &amp;p) {
    const int slen = s.length(), plen = p.length();
    vector&lt;vector&lt;int&gt; &gt; f(slen+1, vector&lt;int&gt;(plen+1, 0));
    f[slen][plen] = 1;
    for (int j=plen-1; j&gt;=1; --j) f[slen][j-1] = p[j] == '*' &amp;&amp; f[slen][j+1];
    for (int i=slen-1; i&gt;=0; --i) for (int j=plen-1; j&gt;=0;) {
        if (s[i] == p[j] || p[j] == '.') { 
            f[i][j] = f[i+1][j+1]; j -= 1; 
        } 
        else if (p[j] == '*') {
            if (p[j-1] == '.' || s[i] == p[j-1]) { 
                f[i][j-1] = f[i][j+1] || f[i+1][j-1] || f[i+1][j+1]; j -= 2; 
            } else if (s[i] != p[j-1]) { 
                f[i][j-1] = f[i][j+1]; j -= 2; 
            }
        }
        else { j -= 1; }
    }
    return f[0][0];
}
};
</code></pre>

<h2 id="11-container-with-most-water">11. Container With Most Water</h2>

<p>链接：<a href="https://leetcode.com/problems/container-with-most-water/">https://leetcode.com/problems/container-with-most-water/</a></p>

<p>思路：</p>

<pre><code class="language-cpp">class Solution {
public:
    int maxArea(vector&lt;int&gt;&amp; heights) {
        int result = 0;
        int i = 0, j = heights.size()-1;
        while (i &lt; j) {
            int hi = heights[i], hj = heights[j];
            int area = min(hi, hj) * (j-i);
            result = max(area, result);
            if      (hi &lt; hj) i++;
            else if (hi &gt; hj) j--;
            else              i++, j--;
        }
        return result;
    }
};
</code></pre>

<h2 id="12-integer-to-roman">12. Integer to Roman</h2>

<p>链接：<a href="https://leetcode.com/problems/integer-to-roman/">https://leetcode.com/problems/integer-to-roman/</a></p>

<pre><code class="language-cpp">class Solution {
public:
    string intToRoman(int num) {
        static string I[] = {&quot;&quot;, &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;, &quot;VI&quot;, &quot;VII&quot;, &quot;VIII&quot;, &quot;IX&quot;};
        static string X[] = {&quot;&quot;, &quot;X&quot;, &quot;XX&quot;, &quot;XXX&quot;, &quot;XL&quot;, &quot;L&quot;, &quot;LX&quot;, &quot;LXX&quot;, &quot;LXXX&quot;, &quot;XC&quot;};
        static string C[] = {&quot;&quot;, &quot;C&quot;, &quot;CC&quot;, &quot;CCC&quot;, &quot;CD&quot;, &quot;D&quot;, &quot;DC&quot;, &quot;DCC&quot;, &quot;DCCC&quot;, &quot;CM&quot;};
        static string M[] = {&quot;&quot;, &quot;M&quot;, &quot;MM&quot;, &quot;MMM&quot;};
        string result; result.reserve(20);
        result.append(M[num/1000]).append(C[num%1000/100]).append(X[num%100/10]).append(I[num%10]);
        return move(result);
    }
};
</code></pre>

<h2 id="13-roman-to-integer">13. Roman To Integer</h2>

<p>链接：<a href="https://leetcode.com/problems/roman-to-integer/">https://leetcode.com/problems/roman-to-integer/</a></p>

<p>思路1：用trie树，没写完。</p>

<pre><code class="language-cpp">class Solution {
public:
    struct TrieNode {
        TrieNode *next[26]; int flag;
        TrieNode() { flag = 0; fill_n(next, 26, nullptr); }
        ~TrieNode() { for (auto p : next) if (p) delete p; }
    }
    
    int romanToInt(const string &amp;s) {
        vector&lt;string&gt; I = {&quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;, &quot;VI&quot;, &quot;VII&quot;, &quot;VIII&quot;, &quot;IX&quot;};
        vector&lt;string&gt; X = {&quot;X&quot;, &quot;XX&quot;, &quot;XXX&quot;, &quot;XL&quot;, &quot;L&quot;, &quot;LX&quot;, &quot;LXX&quot;, &quot;LXXX&quot;, &quot;XC&quot;};
        vector&lt;string&gt; C = {&quot;C&quot;, &quot;CC&quot;, &quot;CCC&quot;, &quot;CD&quot;, &quot;D&quot;, &quot;DC&quot;, &quot;DCC&quot;, &quot;DCCC&quot;, &quot;CM&quot;};
        vector&lt;string&gt; M = {&quot;M&quot;, &quot;MM&quot;, &quot;MMM&quot;};
        static TrieNode *root = nullptr;
        if (root == nullptr) {
            root = new TrieNode();
            for (auto &amp;ss : {I, X, C, M}) for (int i = 0; i &lt; ss.length(); ++i) {
                TrieNode *p = root;
                for (char c : s) {
                    if (p-&gt;next(s-'A') == nullptr) p-&gt;next(s-'A') = new TrieNode();
                    p = p-&gt;next(s-'A');
                }
                p-&gt;flag = (i-0+1) * 10;
            }
        }
    }
};
</code></pre>

<p>思路2：从后往前</p>

<pre><code class="language-cpp">class Solution {
public:
    int romanToInt(const string &amp;s) {
        static unordered_map&lt;char, int&gt; f;
        if (f.size() == 0) 
            f = {{'I',1}, {'V',5}, {'X',10}, {'L',50}, {'C',100}, {'D',500}, {'M',1000}};

        int result = f[s.back()];
        for (int i = s.length()-2; i &gt;= 0; --i) 
            if (f[s[i]] &lt; f[s[i+1]]) result -= f[s[i]];
            else                     result += f[s[i]];
        return result;
    }
};

</code></pre>

<h2 id="14-longest-common-prefix">14. Longest Common Prefix</h2>

<p>链接：<a href="https://leetcode.com/problems/longest-common-prefix/">https://leetcode.com/problems/longest-common-prefix/</a></p>

<pre><code class="language-cpp">class Solution {
public:
    string longestCommonPrefix(vector&lt;string&gt;&amp; strs) {
        if (strs.empty()) return &quot;&quot;;
        if (strs.size() == 1) return strs.front();
        sort(strs.begin(), strs.end());
        string result, &amp;a = strs.front(), &amp;b = strs.back();
        int len = min(a.length(), b.length());
        for (int i = 0; i &lt; len; i++) 
            if (a[i] == b[i]) result.push_back(a[i]); else break;
        return move(result);
    }
};
</code></pre>

<h2 id="15-3sum">15. 3Sum</h2>

<p>链接：<a href="https://leetcode.com/problems/3sum/">https://leetcode.com/problems/3sum/</a></p>

<p>思路：</p>

<ol>
<li>先排序.</li>
<li>固定l，调整i和h,加和，大于0则减小h，小于0则增大i，等于0则减小h增大i，注意去重.</li>
<li>迭代第2步，l从0到len-3.</li>
</ol>

<pre><code class="language-cpp">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {
        sort(nums.begin(), nums.end());
        vector&lt;vector&lt;int&gt;&gt; result; int l=0, len=nums.size();
        while (l &lt;= len-3) {
            for (int i = l+1, h=len-1; i &lt;= h-1;) {
                int sum = nums[l] + nums[i] + nums[h];
                if      (sum &gt; 0) for (h--; i&lt;=h-1&amp;&amp;nums[h]==nums[h+1]; h--);
                else if (sum &lt; 0) for (i++; i&lt;=h-1&amp;&amp;nums[i]==nums[i-1]; i++);
                else if (sum == 0) {
                    result.push_back({nums[l], nums[i], nums[h]});
                    for (i++, h--; i&lt;=h-1&amp;&amp;nums[i]==nums[i-1]; i++);
                } 
            }
            for (l++; l&lt;=len-3&amp;&amp;nums[l-1]==nums[l]; l++);
        }
        return result;
    }
};
</code></pre>

<h2 id="16-3sum-closest">16. 3Sum Closest</h2>

<p>链接：<a href="https://leetcode.com/problems/3sum-closest/">https://leetcode.com/problems/3sum-closest/</a></p>

<p>13ms</p>

<pre><code class="language-cpp">class Solution {
public:
    int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) {
        sort(nums.begin(), nums.end());
        int l = 0, len = nums.size(), result = nums[0]+nums[1]+nums[2];
        for (l = 0; l &lt;= len-3; ++l) for (int i=l+1, h=len-1; i &lt;= h-1;) {
            int sum = nums[l] + nums[i] + nums[h];
            result = abs(sum-target) &lt; abs(result-target) ? sum : result;
            if      (sum &lt; target) { for (i++; i&lt;=h-1 &amp;&amp; nums[i]==nums[i-1]; i++); }
            else if (sum &gt; target) { for (h--; i&lt;=h-1 &amp;&amp; nums[h]==nums[h+1]; h--); }
            else                   { return sum; }
        }
        return result;
    }
};
</code></pre>

<p>和上面的差不多时间，12ms</p>

<pre><code class="language-cpp">class Solution {
public:
    int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) {
        sort(nums.begin(), nums.end());
        int l = 0, len = nums.size(), result = nums[0]+nums[1]+nums[2];
        while (l &lt;= len-3) { 
            for (int i=l+1, h=len-1; i &lt;= h-1;) {
                int sum = nums[l] + nums[i] + nums[h];
                result = abs(sum-target) &lt; abs(result-target) ? sum : result;
                if      (sum &lt; target) { for (i++; i&lt;=h-1 &amp;&amp; nums[i]==nums[i-1]; i++); }
                else if (sum &gt; target) { for (h--; i&lt;=h-1 &amp;&amp; nums[h]==nums[h+1]; h--); }
                else                   { return sum; }
            }
            for (l++; l&lt;=len-3 &amp;&amp; nums[l]==nums[l-1]; l++);
        }
        return result;
    }
};
</code></pre>

<h2 id="17-letter-combinations-of-a-phone-number">17. Letter Combinations of a Phone Number</h2>

<p>思路：对于每个数字，将当前的result和空tmp交换，然后对tmp中的每个word，追加c后，添加到result.</p>

<pre><code class="language-cpp">class Solution {
public:
    vector&lt;string&gt; letterCombinations(const string&amp; digits) {
        static vector&lt;string&gt; ss = {&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;};
        vector&lt;string&gt; result;
        for (auto d : digits) {
            int idx = d - '0' - 2;
            if (idx &lt; 0 || idx &gt;= 8) { continue; }
            string s = ss[idx];
            if (result.empty()) { result.push_back(&quot;&quot;); }
            vector&lt;string&gt; tmp; result.swap(tmp);
            for (auto c : s) for (auto it : tmp) {
                it.push_back(c); result.push_back(it);
            }
        }
        return move(result);
    }
};
</code></pre>

<h2 id="18-4sum">18. 4Sum</h2>

<p>链接：<a href="https://leetcode.com/problems/4sum/">https://leetcode.com/problems/4sum/</a></p>

<p>思路：在3Sum的基础上，多做一层循环</p>

<pre><code class="language-cpp">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) {
        sort(nums.begin(), nums.end());
        vector&lt;vector&lt;int&gt;&gt; result; int len=nums.size();
        for (int i=0; i&lt;=len-4;) {
            for (int j=i+1; j&lt;=len-3;) {
                for (int k=j+1, l=len-1; k&lt;l;) {
                    int sum = nums[i] + nums[j] + nums[k] + nums[l];
                    if      (sum &gt; target) for (l--; k&lt;l&amp;&amp;nums[l]==nums[l+1]; l--);
                    else if (sum &lt; target) for (k++; j&lt;k&amp;&amp;nums[k]==nums[k-1]; k++);
                    else if (sum == target) {
                        result.push_back({nums[i], nums[j], nums[k], nums[l]});
                        for (k++, l--; k&lt;l&amp;&amp;nums[k]==nums[k-1]; k++);
                    } 
                }
                for (j++; j&lt;=len-3&amp;&amp;nums[j-1]==nums[j]; j++);
            }
            for (i++; i&lt;=len-4&amp;&amp;nums[i-1]==nums[i]; i++);
        }
        return move(result);
    }
};
</code></pre>

<p>整理下，可以改改就能过threeSum和twoSum，还有点优化，在nSum中通过最小值和最大值乘以n和target做比较来截枝，这边就没做了。</p>

<pre><code class="language-cpp">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) {
        vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path;
        if (nums.size() &lt; 4) return result;
        sort(nums.begin(), nums.end());
        fourSum(nums, target, 0, path, result);
        return move(result);
    }
    
    void fourSum(vector&lt;int&gt; &amp;nums, int target, int low, vector&lt;int&gt; &amp;path, vector&lt;vector&lt;int&gt;&gt; &amp;result) {
        for (int i=low; i&lt;=nums.size()-4; i++) {
            if (i&gt;low &amp;&amp; nums[i-1]==nums[i]) continue;
            path.push_back(nums[i]);
            threeSum(nums, target-nums[i], i+1, path, result);
            path.pop_back();
        }
    }
    
    void threeSum(vector&lt;int&gt; &amp;nums, int target, int low, vector&lt;int&gt; &amp;path, vector&lt;vector&lt;int&gt;&gt; &amp;result) {
        for (int i=low; i&lt;=nums.size()-3; i++) {
            if (i&gt;low &amp;&amp; nums[i-1] == nums[i]) continue;
            path.push_back(nums[i]);
            twoSum(nums, target-nums[i], i+1, path, result);
            path.pop_back();
        }
    }
    
    void twoSum(vector&lt;int&gt; &amp;nums, int target, int low, vector&lt;int&gt; &amp;path, vector&lt;vector&lt;int&gt;&gt; &amp;result) {
        int i=low, j=nums.size()-1;
        while (i &lt; j) {
            int sum = nums[i] + nums[j];
            if (sum == target) {
                vector&lt;int&gt; tmp = path; tmp.push_back(nums[i]); tmp.push_back(nums[j]);
                result.push_back(tmp);
                for (i++, j--; i&lt;j &amp;&amp; nums[i-1]==nums[i]; ++i);
            } 
            else if (sum &gt; target) for (j--; i&lt;j&amp;&amp;nums[j]==nums[j+1]; j--);
            else if (sum &lt; target) for (i++; i&lt;j&amp;&amp;nums[i-1]==nums[i]; i++);
        }
    }
};
</code></pre>

<h2 id="19-remove-nth-node-from-end-of-list">19. Remove Nth Node From End of List</h2>

<p>链接：<a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/#/description">https://leetcode.com/problems/remove-nth-node-from-end-of-list/#/description</a></p>

<p>两趟遍历</p>

<pre><code class="language-cpp">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode *p;
        int len = 0; for (p = head; p != nullptr; p = p-&gt;next) len++;
        if (n &gt;  len) return head;
        if (n == len) return head-&gt;next;
        p = head; for (int i = 0; i &lt; len - n - 1; i++) p = p-&gt;next;
        ListNode *tmp = p-&gt;next;
        p-&gt;next = p-&gt;next-&gt;next;
        delete tmp;
        return head;
    }
};
</code></pre>

<p>单趟遍历</p>

<pre><code class="language-cpp">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode *p = head;
        for (int i = 0; i &lt; n; i++) { if (!p) return head; p = p-&gt;next; }
        ListNode dummy(0); ListNode *pre = &amp;dummy; pre-&gt;next = head;
        for (; p != nullptr; p = p-&gt;next) { pre = pre-&gt;next; }
        ListNode *tmp = pre-&gt;next;
        pre-&gt;next = pre-&gt;next-&gt;next;
        delete tmp;
        return dummy.next;
    }
};
</code></pre>

<p>注意，如果把delete tmp注释掉，速度就能快上很多。不注释，就只能打败6%。深深怀疑，大部分同志忘记了delete tmp了。</p>

<h2 id="20-valid-parentheses">20. Valid Parentheses</h2>

<p>链接：<a href="https://leetcode.com/problems/valid-parentheses/#/description">https://leetcode.com/problems/valid-parentheses/#/description</a></p>

<p>使用单纯的比较 beat 15.3%</p>

<pre><code class="language-cpp">class Solution {
public:
    bool isValid(string s) {
        stack&lt;char&gt; stk;
        for (auto c : s) {
            if (!stk.empty() &amp;&amp; (stk.top()=='(' &amp;&amp; c==')' || stk.top()=='[' &amp;&amp; c==']' || stk.top()=='{' &amp;&amp; c=='}')) { 
                stk.pop(); 
            } else {
                stk.push(c);
            }
        }
        return stk.empty();
    }
};
</code></pre>

<p>使用hashmap，beat 1.73%</p>

<pre><code class="language-cpp">class Solution {
public:
    bool isValid(string s) {
        stack&lt;char&gt; stk;
        for (auto c : s) {
            unordered_map&lt;char, char&gt; tbl = {{'(',')'},{'{','}'},{'[',']'}};
            if (!stk.empty() &amp;&amp; tbl[stk.top()] == c) { 
                stk.pop(); 
            } else {
                stk.push(c);
            }
        }
        return stk.empty();
    }
};
</code></pre>

<p>打表法 beat 15%</p>

<pre><code class="language-cpp">class Solution {
public:
    bool isValid(string s) {
        stack&lt;char&gt; stk; char tbl[256] = {0};
        tbl['('] = ')'; tbl['['] = ']'; tbl['{'] = '}';
        for (auto c : s) {
            if (!stk.empty() &amp;&amp; tbl[stk.top()] == c) { 
                stk.pop(); 
            } else {
                stk.push(c);
            }
        }
        return stk.empty();
    }
};
</code></pre>
    </div>

    
    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">amendgit</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">2018-06-01</span>
  </p>
  
  
</div>

    
    

    <footer class="post-footer">
      <div class="post-tags">
          
          <a href="/tags/leetcode/">leetcode</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/leetcode/leetcode-solutions-021-040/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Leetcode Solutions 021 040</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/cs224n/cs224n-assignment-2/">
            <span class="next-text nav-default">cs224n assignment 2</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:shijian0912@163.com" class="iconfont icon-email" title="email"></a>
      <a href="http://localhost:1313" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
      <a href="http://localhost:1313" class="iconfont icon-twitter" title="twitter"></a>
      <a href="http://localhost:1313" class="iconfont icon-facebook" title="facebook"></a>
      <a href="http://localhost:1313" class="iconfont icon-linkedin" title="linkedin"></a>
      <a href="http://localhost:1313" class="iconfont icon-google" title="google"></a>
      <a href="http://localhost:1313" class="iconfont icon-github" title="github"></a>
      <a href="http://localhost:1313" class="iconfont icon-weibo" title="weibo"></a>
      <a href="http://localhost:1313" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="http://localhost:1313" class="iconfont icon-douban" title="douban"></a>
      <a href="http://localhost:1313" class="iconfont icon-pocket" title="pocket"></a>
      <a href="http://localhost:1313" class="iconfont icon-tumblr" title="tumblr"></a>
      <a href="http://localhost:1313" class="iconfont icon-instagram" title="instagram"></a>
  <a href="http://localhost:1313/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    
      2017 - 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">amendgit</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>








</body>
</html>
