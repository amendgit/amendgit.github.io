<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Leetcode Solutions 061 080 - amendgit`s blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="amendgit" />
  <meta name="description" content="本文用来记录我的leetcode解题报告，用于之后的代码优化、查阅和复习。这里是第61题到第80题。

" />

  <meta name="keywords" content="amendgit, blog" />






<meta name="generator" content="Hugo 0.48" />


<link rel="canonical" href="http://localhost:1313/post/leetcode/leetcode-solutions-061-080/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">







<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="Leetcode Solutions 061 080" />
<meta property="og:description" content="本文用来记录我的leetcode解题报告，用于之后的代码优化、查阅和复习。这里是第61题到第80题。

" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/post/leetcode/leetcode-solutions-061-080/" /><meta property="article:published_time" content="2018-08-02T11:33:25&#43;08:00"/>
<meta property="article:modified_time" content="2018-08-02T11:33:25&#43;08:00"/>
<meta itemprop="name" content="Leetcode Solutions 061 080">
<meta itemprop="description" content="本文用来记录我的leetcode解题报告，用于之后的代码优化、查阅和复习。这里是第61题到第80题。

">


<meta itemprop="datePublished" content="2018-08-02T11:33:25&#43;08:00" />
<meta itemprop="dateModified" content="2018-08-02T11:33:25&#43;08:00" />
<meta itemprop="wordCount" content="4515">



<meta itemprop="keywords" content="leetcode," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Leetcode Solutions 061 080"/>
<meta name="twitter:description" content="本文用来记录我的leetcode解题报告，用于之后的代码优化、查阅和复习。这里是第61题到第80题。

"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">amendgit&#39;s blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">amendgit&#39;s blog</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Leetcode Solutions 061 080</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-08-02 </span>
        
        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#61-rotate-list">61. Rotate List</a></li>
<li><a href="#62-unique-paths">62. Unique Paths</a></li>
<li><a href="#63-unique-paths-ii">63. Unique Paths II</a></li>
<li><a href="#64-minimum-path-sum">64. Minimum Path Sum</a></li>
<li><a href="#65-valid-number">65. Valid Number</a></li>
<li><a href="#66-plus-one">66. Plus One</a></li>
<li><a href="#67-add-binary">67. Add Binary</a></li>
<li><a href="#68-text-justification">68. Text Justification</a></li>
<li><a href="#69-sqrt-x">69. Sqrt(x)</a></li>
<li><a href="#70-climbing-stairs">70. Climbing Stairs</a></li>
<li><a href="#71-simplify-path">71. Simplify Path</a></li>
<li><a href="#72-edit-distance">72. Edit Distance</a></li>
<li><a href="#73-set-matrix-zeroes">73. Set Matrix Zeroes</a></li>
<li><a href="#74-search-a-2d-matrix">74. Search a 2D Matrix</a></li>
<li><a href="#75-sort-colors">75. Sort Colors</a></li>
<li><a href="#76-minimum-window-substring">76. Minimum Window Substring</a></li>
<li><a href="#77-combinations">77. Combinations</a></li>
<li><a href="#78-subsets">78. Subsets</a></li>
<li><a href="#79-word-search">79. Word Search</a></li>
<li><a href="#80-remove-duplicates-from-sorted-array-ii">80. Remove Duplicates from Sorted Array II</a></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    

    
    <div class="post-content">
      <p>本文用来记录我的leetcode解题报告，用于之后的代码优化、查阅和复习。这里是第61题到第80题。</p>

<p></p>

<h2 id="61-rotate-list">61. Rotate List</h2>

<p>链接：<a href="https://leetcode.com/problems/rotate-list/">https://leetcode.com/problems/rotate-list/</a></p>

<p>思路：先计算链表长度len，双指针p1和p2，p1先走k步，开始同时走p1和p2，当p1-&gt;next指向null时，p2指向倒数第k+1个元素，调整两部分链表的前后顺序即可。</p>

<pre><code class="language-cpp">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        ListNode *p1=head, *p2=head;
        int len=0; while (p1!=nullptr) { p1=p1-&gt;next; len++; }
        if (len == 0) return NULL;
        k = k % len; p1 = head;
        if (k == 0) return head;
        for (int i=0; i&lt;k; ++i) p1 = p1-&gt;next;
        while (p1-&gt;next != nullptr) { p1 = p1-&gt;next; p2 = p2-&gt;next; }
        p1-&gt;next = head; head = p2-&gt;next; p2-&gt;next = nullptr;
        return head;
    }
};
</code></pre>

<h2 id="62-unique-paths">62. Unique Paths</h2>

<p>链接: <a href="https://leetcode.com/problems/unique-paths/description/">https://leetcode.com/problems/unique-paths/description/</a></p>

<p>思路: 每一个格子的可能路径数等于左边格子路径书加上上方格子路径数。</p>

<pre><code class="language-cpp">class Solution {
public:
    int uniquePaths(int m, int n) {
        vector&lt;vector&lt;int&gt;&gt; tbl(m, vector&lt;int&gt;(n, 0));
        tbl[0][0] = 1;
        for (int i = 0; i &lt; m; i++) for (int j = 0; j &lt; n; j++) {
            (i &gt; 0) &amp;&amp; (tbl[i][j] += tbl[i-1][j]);
            (j &gt; 0) &amp;&amp; (tbl[i][j] += tbl[i][j-1]);
        }
        return tbl.back().back();
    }
};
</code></pre>

<h2 id="63-unique-paths-ii">63. Unique Paths II</h2>

<p>链接：<a href="https://leetcode.com/problems/unique-paths-ii/description/">https://leetcode.com/problems/unique-paths-ii/description/</a></p>

<p>思路：注意 [0, 0]位置 和 [m, n] 位置不能为1。可以复用grid作为表用，加和时需要判断一下[i, j]是否为1，已经邻居格是否为1。</p>

<pre><code class="language-cpp">class Solution {
public:
    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        if (grid.empty() || grid.front().empty()) return 0;
        if (grid.front().front() || grid.back().back()) return 0; 
        grid[0][0] = -1;
        for (int i = 0; i &lt; grid.size(); i++) for (int j = 0; j &lt; grid.front().size(); j++) {
            if (grid[i][j] == 1) continue;
            (j &gt; 0) &amp;&amp; (grid[i][j-1] &lt; 0) &amp;&amp; (grid[i][j] += grid[i][j-1]);
            (i &gt; 0) &amp;&amp; (grid[i-1][j] &lt; 0) &amp;&amp; (grid[i][j] += grid[i-1][j]);
        }
        return -grid.back().back();
    }
};
</code></pre>

<h2 id="64-minimum-path-sum">64. Minimum Path Sum</h2>

<p>链接：<a href="https://leetcode.com/problems/minimum-path-sum/description/">https://leetcode.com/problems/minimum-path-sum/description/</a></p>

<p>思路：和62题63题类似，区别在于从左边和上方找到较小的值加和，就是当前格子的最小路径和，注意边界的处理。比较简单，一遍通过。</p>

<pre><code class="language-cpp">class Solution {
public:
    int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        int m = grid.size();         if (m == 0) return 0;
        int n = grid.front().size(); if (n == 0) return 0;
        for (int i=0; i&lt;m; i++) for (int j=0; j&lt;n; j++) {
            (i == 0 &amp;&amp; j &gt;  0) &amp;&amp; (grid[i][j] += grid[i][j-1]);
            (i &gt;  0 &amp;&amp; j == 0) &amp;&amp; (grid[i][j] += grid[i-1][j]);
            (i &gt;  0 &amp;&amp; j &gt;  0) &amp;&amp; (grid[i][j] += min(grid[i-1][j], grid[i][j-1]));
        }
        return grid.back().back();
    }
};
</code></pre>

<h2 id="65-valid-number">65. Valid Number</h2>

<p>链接：<a href="https://leetcode.com/problems/valid-number/">https://leetcode.com/problems/valid-number/</a></p>

<p>思路：用状态机，transition的条件为输入字符的类型，状态为0到9，其中0表示开始，99表示成功结束。每行表示从当前状态（行下标）遇到对应的条件跳转到的下一个状态，-1表示无效终止。其他思路，一个完整的数字包括+123.123e+123，其中符号部分是可选的，第一个123和第二个123必须出现一个，最后的e部分也是可选的。</p>

<pre><code class="language-cpp">class Solution {
public:
    bool isNumber(const string &amp;s) {
        enum ConditionType {
            INVALID, SPACE, SIGN, DIGIT, DOT, EXPONENT, ENDSTR, NUMINPUTS
        };
        int next[][NUMINPUTS] = {
            -1,       0,     1,    2,     3,  -1,       -1, // 0
            -1,      -1,    -1,    2,     3,  -1,       -1, // 1
            -1,       9,    -1,    2,     4,   5,       99, // 2
            -1,      -1,    -1,    6,    -1,  -1,       -1, // 3
            -1,       9,    -1,    6,    -1,   5,       99, // 4
            -1,      -1,     7,    8,    -1,  -1,       -1, // 5
            -1,       9,    -1,    6,    -1,   5,       99, // 6
            -1,      -1,    -1,    8,    -1,  -1,       -1, // 7
            -1,       9,    -1,    8,    -1,  -1,       99, // 8
            -1,       9,    -1,   -1,    -1,  -1,       99, // 9
        };
        int state = 0, condition;
        for (auto ch : s) {
            if (isspace(ch))                 condition = SPACE;
            else if (isdigit(ch))            condition = DIGIT;
            else if (ch=='+' || ch=='-')     condition = SIGN;
            else if (ch == '.')              condition = DOT;
            else if (ch == 'E' || ch == 'e') condition = EXPONENT;
            else                             condition = INVALID;
            state = next[state][condition];
            if (state == -1) return false;
        }
        return next[state][ENDSTR] == 99;
    }
};
</code></pre>

<h2 id="66-plus-one">66. Plus One</h2>

<p>链接：<a href="https://leetcode.com/problems/plus-one/description/">https://leetcode.com/problems/plus-one/description/</a></p>

<p>思路：加1，逐一计算carry，比较简单，一遍过。</p>

<pre><code class="language-cpp">class Solution {
public:
    vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) {
        const int len = digits.size();
        if (len == 0) return vector&lt;int&gt;();
        int carry = 0; digits[len-1] += 1;
        for (int i=len-1; i&gt;=0; i--) {
            digits[i] += carry;
            carry = digits[i] / 10;
            digits[i] %= 10;
        }
        if (carry != 0) {
            digits.insert(begin(digits), carry);
        }
        return digits;
    }
};
</code></pre>

<h2 id="67-add-binary">67. Add Binary</h2>

<p>链接：<a href="https://leetcode.com/problems/add-binary/description/">https://leetcode.com/problems/add-binary/description/</a></p>

<p>思路：从后依次往前加，注意carry即可。</p>

<pre><code class="language-cpp">class Solution {
public:
    string addBinary(const string &amp;a, const string &amp;b) {
        int alen=a.length(), blen=b.length(), len=max(alen, blen), carry=0;
        if (len == 0) return &quot;&quot;;
        string c(len, '0');
        for (int i=0; i&lt;len; i++) {
            (i &lt; alen) &amp;&amp; (carry += a[alen-i-1]-'0');
            (i &lt; blen) &amp;&amp; (carry += b[blen-i-1]-'0');
            c[len-i-1] = carry % 2 + '0';
            carry = carry / 2;
        }
        if (carry != 0) c.insert(begin(c), carry+'0');
        return move(c);
    }
};
</code></pre>

<h2 id="68-text-justification">68. Text Justification</h2>

<p>链接：<a href="https://leetcode.com/problems/text-justification/description/">https://leetcode.com/problems/text-justification/description/</a></p>

<p>思路：逐行处理，先计算出当前行最大包含的单词，然后计算总空格数，分别处理 单个单词 最后一行 常规 等三种情况。其中 单个单词 和 最后一行 的处理不能交换，是因为什么呢？</p>

<pre><code class="language-cpp">class Solution {
public:
    vector&lt;string&gt; fullJustify(const vector&lt;string&gt;&amp; S, const int W) {
        vector&lt;string&gt; result; int p = 0;
        while (p &lt; S.size()) {
            result.push_back(nextJustifyLine(S, p, W));
        }
        return result;
    }
    
    string nextJustifyLine(const vector&lt;string&gt; &amp;S, int &amp;p, const int W) {
        string line; vector&lt;string&gt; w; int Nw = 0; line.reserve(W);
        while (p &lt; S.size() &amp;&amp; (Nw + S[p].length() + w.size() &lt;= W)) {
            w.push_back(S[p]); Nw += S[p].length(); p++;
        }
        const int Ns = W - Nw, Np = w.size() - 1; // num of spaces and num of pos.
        if (w.size() == 1) {
            line.append(w[0]).append(Ns, ' ');
        } else if (p == S.size()) {            // last line.
            for (int i=0; i&lt;=w.size()-2; i++) 
                line.append(w[i]).push_back(' ');
            line.append(w.back()).append(Ns-Np, ' ');
        } else {
            for (int i=0; i&lt;=w.size()-2; i++) 
                line.append(w[i]).append(Ns / Np + (i &lt; Ns%Np ? 1 : 0), ' ');
            line.append(w.back());
        }
        return move(line);
    }
};
</code></pre>

<h2 id="69-sqrt-x">69. Sqrt(x)</h2>

<p>链接；<a href="https://leetcode.com/problems/sqrtx/description/">https://leetcode.com/problems/sqrtx/description/</a></p>

<p>思路：这题比较简单，注意nxn不溢出就可以了。</p>

<pre><code class="language-cpp">class Solution {
public:
    int mySqrt(int x) {
        for (long n = 0; n &lt;= (x/2+2); n++) if (n * n &gt; x) return n-1;
        return 0;
    }
};
</code></pre>

<h2 id="70-climbing-stairs">70. Climbing Stairs</h2>

<p>链接：<a href="https://leetcode.com/problems/climbing-stairs/description/">https://leetcode.com/problems/climbing-stairs/description/</a></p>

<p>思路：f(n) = f(n-1) + f(n-2)，第n步的可能性等于第n-1步加上第n-2步。以此内推即可。</p>

<pre><code class="language-cpp">class Solution {
public:
    int climbStairs(int n) {
        if (n &lt;= 2) return n;
        int a = 3, b = 2, c  = 1;
        for (int i = 3; i &lt;= n; i++) {
            a = b + c; c = b; b = a;
        }
        return a;
    }
};
</code></pre>

<h2 id="71-simplify-path">71. Simplify Path</h2>

<p>链接：<a href="https://leetcode.com/problems/simplify-path/">https://leetcode.com/problems/simplify-path/</a></p>

<p>思路：将每个有效的component存储再数组中，过程中移除空目录，处理特殊的目录如&rdquo;..&ldquo;和&rdquo;.&ldquo;，注意vector为空时，pop_back会报异常。注意if和elseif的匹配问题，这题必须要加上大括号，想想为什么。</p>

<pre><code class="language-cpp">class Solution {
public:
    string simplifyPath(string&amp; path) {
        const int len = path.length(); int l=1, h=1; vector&lt;string&gt; p;
        if (len==0 || path[0]!='/') return &quot;&quot;;
        while (l &lt; len) {
            while (h&lt;len &amp;&amp; path[h]!='/') h++;
            string tmp = path.substr(l, h-l);
            if      (tmp == &quot;..&quot;)       { if (!p.empty()) p.pop_back(); }
            else if (tmp!=&quot;.&quot; &amp;&amp; h-l&gt;0) { p.push_back(move(tmp)); }
            l = ++h;
        }
        if (p.empty()) return &quot;/&quot;;
        string result;
        for (auto&amp; s : p) { result.push_back('/'); result.append(s); }
        return move(result);
    }
};
</code></pre>

<pre><code class="language-cpp">class Solution {
public:
    string simplifyPath(string&amp; path) {
        const int len = path.length(); int l=1, h=1; vector&lt;string&gt; p;
        if (len==0 || path[0]!='/') return &quot;&quot;;
        while (l &lt; len) {
            while (h&lt;len &amp;&amp; path[h]!='/') h++;
            string tmp = path.substr(l, h-l);
            if      (tmp == &quot;..&quot;) { if (!p.empty()) p.pop_back(); }
            else if (tmp == &quot;.&quot; ) { /* do nothing */              }
            else if (h - l &gt; 0  ) { p.push_back(move(tmp));       }
            l = ++h;
        }
        if (p.empty()) return &quot;/&quot;;
        string result;
        for (auto&amp; s : p) { result.append(&quot;/&quot;).append(s); }
        return move(result);
    }
};
</code></pre>

<h2 id="72-edit-distance">72. Edit Distance</h2>

<p>链接：<a href="https://leetcode.com/problems/edit-distance/description/">https://leetcode.com/problems/edit-distance/description/</a></p>

<p>思路：动态规划，<code>dp[i][j]</code>表示<code>src[0, i-1]</code>与<code>tar[0, j-1]</code>的编辑举例，</p>

<p>如果<code>src[i-1]</code>等于<code>tar[j-1]</code>，那么<code>dp[i][j] == dp[i-1][j-1]</code>，因为无需额外的编辑操作。</p>

<p>如果<code>src[i-1] != tar[j-1]</code>，那么有三种编辑可能，</p>

<p>1 一是在<code>dp[i-1][j-1]</code>基础上通过替换<code>src[i-1]</code>为<code>tar[j-1]</code>得来，
2 二是在<code>dp[i][j-1]</code>基础上从<code>src[i-1]</code>的位置插入一个字符得来，
3 三是从<code>dp[i-1][j]</code>基础上通过删除<code>src[i-1]</code>位置的一个字符得来。所以，取三种可能的最小值并加上一步编辑距离。</p>

<p>另外，初始化<code>dp[i][0]</code>表示目标字符串为空的情况，那么只要删除src中的i个字符即可，操作步骤为i。<code>dp[0][j]</code>表示源字符串为空，那么添加j个字符即可，操作步骤数为j。</p>

<p>最后，其实每步计算，只需要左方 右方和上方的dp值即可，可以把二维表简化为单行来计算，可以把空间从O(mn)减少到O(n)。</p>

<pre><code class="language-cpp">class Solution {
public:
    int minDistance(const string &amp;src, const string &amp;tar) {
        int m=src.size(), n=tar.size();
        vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0));
        for (int i=1; i&lt;m+1; i++) dp[i][0] = i;
        for (int j=1; j&lt;n+1; j++) dp[0][j] = j;
        for (int i=1; i&lt;m+1; i++) for (int j=1; j&lt;n+1; j++) {
            if (src[i-1] == tar[j-1]) { 
                dp[i][j] = dp[i-1][j-1]; 
            } else {
                dp[i][j] = min({dp[i][j-1], dp[i-1][j], dp[i-1][j-1]}) + 1;
            }
        }
        return dp[m][n];
    }
};
</code></pre>

<h2 id="73-set-matrix-zeroes">73. Set Matrix Zeroes</h2>

<p>思路：用第一行和第一列标记，对应的列和行是否需要填充0，用r0和c0标记第一行和第一列是否需要填充0。</p>

<p>链接：<a href="https://leetcode.com/problems/set-matrix-zeroes/description/">https://leetcode.com/problems/set-matrix-zeroes/description/</a></p>

<pre><code class="language-cpp">class Solution {
public:
    void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; M) {
        const int m = M.size(); if (m == 0) return;
        const int n = M[0].size();
        int r0 = 1, c0 = 1;
        for (int i=0; i&lt;m; i++) if (!M[i][0]) c0 = 0;
        for (int j=0; j&lt;n; j++) if (!M[0][j]) r0 = 0;
        
        for (int i=1; i&lt;m; i++) for (int j=1; j&lt;n; j++) 
            if (!M[i][j]) M[i][0] = M[0][j] = 0;
        
        for (int i=1; i&lt;m; i++) for (int j=1; j&lt;n; j++)
            if (!M[i][0] || !M[0][j]) M[i][j] = 0;
        
        if (!c0) for (int i=0; i&lt;m; i++) M[i][0] = 0;
        if (!r0) for (int j=0; j&lt;n; j++) M[0][j] = 0;
    }
};
</code></pre>

<h2 id="74-search-a-2d-matrix">74. Search a 2D Matrix</h2>

<p>链接：<a href="https://leetcode.com/problems/search-a-2d-matrix/description/">https://leetcode.com/problems/search-a-2d-matrix/description/</a></p>

<p>思路：先顺着第一列查找，再查找对应的行，可以用binary_search提一下速。有时间的话，也可以考虑自己手撸一个二分查找。</p>

<pre><code class="language-cpp">class Solution {
public:
    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; M, int T) {
        const int m = M.size();    if (m == 0) return false;
        const int n = M[0].size(); if (n == 0) return false;
        int i = 0;
        for (i=0; i&lt;m; i++) if (M[i].front()&lt;=T &amp;&amp; T&lt;=M[i].back()) break;
        if (i == m) return false;
        return binary_search(begin(M[i]), end(M[i]), T);
    }
};
</code></pre>

<h2 id="75-sort-colors">75. Sort Colors</h2>

<p>链接：<a href="https://leetcode.com/problems/sort-colors/description/">https://leetcode.com/problems/sort-colors/description/</a></p>

<p>思路：题目的Follow up，要单趟排序还是挺难的，和《算法导论》里的快排思路挺类似的，区别是这个有三类。不过理解了，就简单了。也就是[0,l)表示0的存放区间，(h, len-1]表示2的存放区间。i从头到尾的扫描，每次遇到就要将元素放置到正确的位置上。要注意 循环条件 <code>i&lt;=h</code>的判断，和向后交换时<code>i--</code>保持i的位置不动。</p>

<pre><code class="language-cpp">class Solution {
public:
    void sortColors(vector&lt;int&gt;&amp; nums) {
        const int len = nums.size();
        int l=0, h=len-1;
        for (int i=0; i&lt;=h; i++) {
            if      (nums[i] == 0) swap(nums[i], nums[l++]);
            else if (nums[i] == 2) swap(nums[i--], nums[h--]);
        }
    }
};
</code></pre>

<h2 id="76-minimum-window-substring">76. Minimum Window Substring</h2>

<p>链接：<a href="https://leetcode.com/problems/minimum-window-substring/">https://leetcode.com/problems/minimum-window-substring/</a></p>

<p>思路：双指针，先移动i直到t中的字符全部在s[l,i]中出现，在移动l使得s[l,i]满足条件的同时i-l最小，计数使用数组。</p>

<pre><code class="language-cpp">class Solution {
public:
    string minWindow(string&amp; s, string&amp; t) {
        int S[256], T[256], l=0, count=0, minl=0, minh=INT_MAX;
        fill_n(S, 256, 0); fill_n(T, 256, 0);
        for (auto c : t) T[c]++;
        for (int i=0; i&lt;s.length(); i++) {
            S[s[i]]++;
            if (S[s[i]] &lt;= T[s[i]]) count++;
            if (count == t.length()) {
                while (S[s[l]] &gt; T[s[l]]) S[s[l++]]--;
                if (minh-minl &gt; i-l) { minh = i; minl = l; }
                S[s[l++]]--; count--;
            }
        }
        if (minh == INT_MAX) return &quot;&quot;;
        return move(s.substr(minl, minh-minl+1));
    }
};
</code></pre>

<h2 id="77-combinations">77. Combinations</h2>

<p>链接：<a href="https://leetcode.com/problems/combinations/description/">https://leetcode.com/problems/combinations/description/</a></p>

<p>思路：用深搜，可以比较轻易的搜出来，就是效率比较低，over 32.4%</p>

<pre><code class="language-cpp">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) {
        vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path;
        dfs(n, k, 1, path, result);
        return move(result);
    }
    
    void dfs(int n, int k, int p, vector&lt;int&gt; &amp;path, vector&lt;vector&lt;int&gt;&gt; &amp;result) {
        if (path.size() == k) { result.push_back(path); return; }
        if (p &gt; n) return;

        dfs(n, k, p+1, path, result);
        
        path.push_back(p);
        dfs(n, k, p+1, path, result);
        path.pop_back();
    }
};
</code></pre>

<h2 id="78-subsets">78. Subsets</h2>

<p>链接：<a href="https://leetcode.com/problems/subsets/description/">https://leetcode.com/problems/subsets/description/</a></p>

<p>思路：可以用dfs，也可以用位操作算法，应该子集的索引刚好和 1 2 3 4 .. n 的二进制表示法中的1的个数相同。</p>

<pre><code class="language-cpp">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) {
        const int len = nums.size(); vector&lt;vector&lt;int&gt;&gt; result;
        for (int i=0; i&lt;(1&lt;&lt;len); i++) {
            vector&lt;int&gt; subset; subset.reserve(len);
            for (int j=0; j&lt;len; j++) if (i &amp; (1&lt;&lt;j)) subset.push_back(nums[j]);
            result.push_back(move(subset));
        }
        return move(result);
    }
};
</code></pre>

<h2 id="79-word-search">79. Word Search</h2>

<p>递归求解</p>

<pre><code class="language-cpp">class Solution {
public:
    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) {
        if (board.empty()) return false;
        for (int x=0; x&lt;board.size(); x++) for (int y=0; y&lt;board[0].size(); y++)
            if (dfs(board, x, y, word, 0)) return true;
        return false;
    }
    
    bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int x, int y, string&amp; word, int i) {
        if (board[x][y] != word[i]) return false;
        if (i == word.size()-1)     return true;
        char c = board[x][y]; board[x][y] = '*'; bool result = false;
        if (x-1 &gt;= 0)              result = result || dfs(board, x-1, y,   word, i+1);
        if (x+1 &lt; board.size())    result = result || dfs(board, x+1, y,   word, i+1);
        if (y-1 &gt;= 0)              result = result || dfs(board, x,   y-1, word, i+1);
        if (y+1 &lt; board[0].size()) result = result || dfs(board, x,   y+1, word, i+1);
        board[x][y] = c;
        return result;
    }
};
</code></pre>

<p>非递归求解</p>

<pre><code class="language-cpp">class Solution {
public:
    int ladderLength(string&amp; start, string&amp; end, unordered_set&lt;string&gt;&amp; words) {
        unordered_set&lt;string&gt; visited, curr, next;
        visited.insert(start), curr.insert(start);
        int depth = 1;
        while (!curr.empty()) {
            depth++;
            for (auto word : curr) {
                for (int i=0; i&lt;word.size(); i++) for (char c='a'; c&lt;='z'; c++) {
                    if (word[i] == c) continue;
                    swap(word[i], c);
                    if (word == end) return depth;
                    if (words.find(word)!=words.end() &amp;&amp; visited.find(word)==visited.end()) 
                        next.insert(word);
                    swap(word[i], c);
                }
            }
            for (auto&amp; word : next) visited.insert(word);
            curr.clear(); swap(curr, next);
        }
        return 0;
    }
};
</code></pre>

<h2 id="80-remove-duplicates-from-sorted-array-ii">80. Remove Duplicates from Sorted Array II</h2>

<p>链接：<a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/description/">https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/description/</a></p>

<p>思路：挺直观的一道题，用p索引处理后数据，用i索引处理前数据，用count来计数即可。</p>

<pre><code class="language-cpp">class Solution {
public:
    int removeDuplicates(vector&lt;int&gt;&amp; N) {
        int p=1, count=1, len=N.size();
        if (len == 0) return 0;
        for (int i=1; i&lt;len; i++) {
            (N[i]!=N[i-1]) &amp;&amp; (count=1);
            (N[i]==N[i-1]) &amp;&amp; (count++);
            if (count &lt;= 2) N[p++] = N[i];
        }
        return p;
    }
};
</code></pre>
    </div>

    
    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">amendgit</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">2018-08-02</span>
  </p>
  
  
</div>

    
    

    <footer class="post-footer">
      <div class="post-tags">
          
          <a href="/tags/leetcode/">leetcode</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/leetcode/leetcode-solutions/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Leetcode Solutions Index</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/leetcode/leetcode-solutions-041-060/">
            <span class="next-text nav-default">Leetcode Solutions 041 060</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:shijian0912@163.com" class="iconfont icon-email" title="email"></a>
      <a href="http://localhost:1313" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
      <a href="http://localhost:1313" class="iconfont icon-twitter" title="twitter"></a>
      <a href="http://localhost:1313" class="iconfont icon-facebook" title="facebook"></a>
      <a href="http://localhost:1313" class="iconfont icon-linkedin" title="linkedin"></a>
      <a href="http://localhost:1313" class="iconfont icon-google" title="google"></a>
      <a href="http://localhost:1313" class="iconfont icon-github" title="github"></a>
      <a href="http://localhost:1313" class="iconfont icon-weibo" title="weibo"></a>
      <a href="http://localhost:1313" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="http://localhost:1313" class="iconfont icon-douban" title="douban"></a>
      <a href="http://localhost:1313" class="iconfont icon-pocket" title="pocket"></a>
      <a href="http://localhost:1313" class="iconfont icon-tumblr" title="tumblr"></a>
      <a href="http://localhost:1313" class="iconfont icon-instagram" title="instagram"></a>
  <a href="http://localhost:1313/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    
      2017 - 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">amendgit</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>








</body>
</html>
